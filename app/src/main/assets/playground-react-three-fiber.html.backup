<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Three Fiber Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
        }
        
        #main-container {
            display: flex;
            width: 100%;
            height: 100%;
        }
        
        #editor-container {
            flex: 0 0 50%;
            width: 50%;
            height: 100%;
            background: #1e1e1e;
            border-right: 1px solid #333;
            overflow: hidden;
        }
        
        #toolbar {
            background: #2d2d2d;
            border-bottom: 1px solid #333;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 40px;
        }
        
        #toolbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        #toolbar-title {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        #framework-badge {
            background: #007acc;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }
        
        #toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #build-button {
            background: #28a745;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        #build-button:hover {
            background: #218838;
        }
        
        #build-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        #build-button.building {
            background: #007bff;
        }
        
        #build-button.error {
            background: #dc3545;
        }
        
        #build-status {
            color: #ccc;
            font-size: 11px;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        #build-status.success {
            color: #28a745;
        }
        
        #build-status.error {
            color: #dc3545;
        }
        
        #build-status.building {
            color: #007bff;
        }
        
        #run-button {
            background: #17a2b8;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        #run-button:hover {
            background: #138496;
        }
        
        #editor {
            width: 100%;
            height: calc(100% - 40px);
        }
        
        #canvas-container {
            flex: 0 0 50%;
            width: 50%;
            height: 100%;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        #root {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            outline: none;
        }
        
        #console {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            max-height: 30%;
            overflow-y: auto;
            border-top: 1px solid #333;
            z-index: 1000;
            display: none;
        }
        
        #console.show {
            display: block;
        }
        
        #console-header {
            background: #1a1a1a;
            padding: 4px 8px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #console-title {
            font-weight: 500;
            font-size: 10px;
            color: #ccc;
        }
        
        #console-clear {
            background: none;
            border: none;
            color: #ccc;
            font-size: 10px;
            cursor: pointer;
            padding: 2px 4px;
        }
        
        #console-content {
            padding: 8px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .console-log { color: #fff; }
        .console-warn { color: #ffc107; }
        .console-error { color: #dc3545; }
        .console-info { color: #17a2b8; }
        
        #loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            z-index: 2000;
        }
        
        .spinner {
            border: 2px solid #333;
            border-top: 2px solid #007acc;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="editor-container">
            <div id="toolbar">
                <div id="toolbar-left">
                    <div id="toolbar-title">React Three Fiber Playground</div>
                    <div id="framework-badge">TSX</div>
                </div>
                <div id="toolbar-right">
                    <div id="build-status">Ready to build</div>
                    <button id="build-button">Build</button>
                    <button id="run-button">Run</button>
                </div>
            </div>
            <div id="editor"></div>
        </div>
        
        <div id="canvas-container">
            <div id="loading-overlay">
                <div class="spinner"></div>
                Initializing React Three Fiber...
            </div>
            <div id="root"></div>
            <canvas id="canvas"></canvas>
            
            <div id="console">
                <div id="console-header">
                    <div id="console-title">Console</div>
                    <button id="console-clear">Clear</button>
                </div>
                <div id="console-content"></div>
            </div>
        </div>
    </div>

    <!-- React Three Fiber Dependencies with CDN fallbacks -->
    
    <!-- Load React directly via script tags -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"
            onload="console.log('‚úÖ ANDROID DEBUG: Babel loaded from CDN:', typeof Babel)"
            onerror="console.error('‚ùå ANDROID DEBUG: Babel failed to load from CDN')">
    </script>

    <!-- Load REAL React Three Fiber and Drei from CDN (iOS version approach) -->
    <!-- Libraries loaded dynamically in initialization - see loadRealR3F() function below -->

    <script>
        // üîí STORAGE POLYFILL - Fix SecurityError for about:blank context
        // React Three Fiber / Drei libraries may try to access sessionStorage/localStorage
        // which is blocked in about:blank WebView context
        (function setupStoragePolyfill() {
            try {
                // Test if storage is accessible
                window.sessionStorage.setItem('__test__', '1');
                window.sessionStorage.removeItem('__test__');
                console.log('‚úÖ ANDROID DEBUG: Native storage is accessible');
            } catch (e) {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: Native storage blocked, installing polyfill...');

                // Create in-memory storage polyfill
                class MemoryStorage {
                    constructor() {
                        this.data = {};
                    }
                    getItem(key) {
                        return this.data[key] || null;
                    }
                    setItem(key, value) {
                        this.data[key] = String(value);
                    }
                    removeItem(key) {
                        delete this.data[key];
                    }
                    clear() {
                        this.data = {};
                    }
                    key(index) {
                        const keys = Object.keys(this.data);
                        return keys[index] || null;
                    }
                    get length() {
                        return Object.keys(this.data).length;
                    }
                }

                // Override storage properties
                try {
                    Object.defineProperty(window, 'sessionStorage', {
                        value: new MemoryStorage(),
                        writable: false,
                        configurable: true
                    });
                    Object.defineProperty(window, 'localStorage', {
                        value: new MemoryStorage(),
                        writable: false,
                        configurable: true
                    });
                    console.log('‚úÖ ANDROID DEBUG: Storage polyfill installed successfully');
                } catch (defineError) {
                    console.error('‚ùå ANDROID DEBUG: Could not install storage polyfill:', defineError);
                }
            }
        })();

        // Track library loading progress
        window.libraryLoadingProgress = {
            React: false,
            ReactDOM: false,
            THREE: false,
            ReactThreeFiber: false,
            Drei: false
        };
        
        let librariesReady = false;

        // Check if basic libraries loaded via script tags and set up globals immediately
        console.log('üîç ANDROID DEBUG: Checking script tag loaded libraries...');
        console.log('   React:', typeof window.React);
        console.log('   ReactDOM:', typeof window.ReactDOM);
        console.log('   THREE:', typeof window.THREE);

        // Initialize function to set up custom R3F implementation
        function initializeR3F() {
            console.log('üìÑ ANDROID DEBUG: Initializing custom R3F implementation...');

            // Check basic libraries are loaded
            console.log('üîç ANDROID DEBUG: Library check:', {
                React: typeof window.React,
                ReactDOM: typeof window.ReactDOM,
                THREE: typeof window.THREE,
                Babel: typeof window.Babel,
                BabelTransform: typeof window.Babel?.transform
            });

            // CRITICAL: Verify Babel is loaded
            if (typeof Babel === 'undefined') {
                console.error('‚ùå ANDROID DEBUG: CRITICAL - Babel not loaded! JSX transformation will fail!');
                console.error('   This will cause "Unexpected token <" errors');
                console.error('   Check network connectivity and CDN access');
                return;
            } else {
                console.log('‚úÖ ANDROID DEBUG: Babel verified loaded:', Babel.version || 'version unknown');
            }

            if (window.React && window.ReactDOM && window.THREE) {
                console.log('‚úÖ ANDROID DEBUG: Basic libraries confirmed');

                // Create custom R3F implementation with Context-based mesh/geometry/material
                console.log('üîß ANDROID DEBUG: Creating custom R3F implementation...');
                createReactThreeFiberGlobalsSync();
                createDreiGlobalsSync();

                // Update progress tracking
                window.libraryLoadingProgress.React = true;
                window.libraryLoadingProgress.ReactDOM = true;
                window.libraryLoadingProgress.THREE = true;
                window.libraryLoadingProgress.ReactThreeFiber = true;
                window.libraryLoadingProgress.Drei = true;
                librariesReady = true;

                // Final verification of all components
                console.log('üîç ANDROID DEBUG: Component verification:', {
                    'ReactThreeFiber.Canvas': !!window.ReactThreeFiber?.Canvas,
                    'ReactThreeFiber.useFrame': !!window.ReactThreeFiber?.useFrame,
                    'ReactThreeFiber.useThree': !!window.ReactThreeFiber?.useThree,
                    'ReactThreeFiber.useLoader': !!window.ReactThreeFiber?.useLoader,
                    'ReactThreeFiber.mesh': !!window.ReactThreeFiber?.mesh,
                    'Drei.OrbitControls': !!window.Drei?.OrbitControls,
                    'Drei.Box': !!window.Drei?.Box,
                    'Drei.Sphere': !!window.Drei?.Sphere
                });

                console.log('‚úÖ ANDROID DEBUG: Custom R3F implementation ready!');
            } else {
                console.error('‚ùå ANDROID DEBUG: Basic libraries not loaded from script tags');
            }
        }

        // Check if DOM is already loaded (inline scripts run after DOM is ready)
        // If not, wait for DOMContentLoaded event
        if (document.readyState === 'loading') {
            console.log('üìÑ ANDROID DEBUG: DOM still loading, waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', initializeR3F);
        } else {
            console.log('üìÑ ANDROID DEBUG: DOM already loaded, initializing immediately...');
            initializeR3F();
        }
        
        // Enhanced library loading with better tracking and validation
        function loadLibraryWithFallback(localPath, cdnPath, globalVar, onLoad) {
            return new Promise((resolve, reject) => {
                console.log(`üîÑ ANDROID DEBUG: Starting load for ${globalVar}...`);
                console.log(`   Local: ${localPath}`);
                console.log(`   CDN: ${cdnPath}`);
                
                const script = document.createElement('script');
                script.src = localPath;
                script.type = 'text/javascript';
                
                // Set a timeout for loading
                const loadTimeout = setTimeout(() => {
                    console.warn(`‚è∞ ANDROID DEBUG: Load timeout for ${globalVar}, trying CDN fallback`);
                    script.remove();
                    tryFallback();
                }, 5000);
                
                script.onload = () => {
                    clearTimeout(loadTimeout);
                    console.log(`‚úÖ ANDROID DEBUG: Script loaded for ${globalVar} from local:`, localPath);
                    
                    // Wait a moment for global variables to be set
                    setTimeout(() => {
                        if (validateLibraryLoaded(globalVar)) {
                            console.log(`‚úÖ ANDROID DEBUG: ${globalVar} validated successfully`);
                            window.libraryLoadingProgress[globalVar] = true;
                            checkLibraryGlobals(globalVar);
                            if (onLoad) onLoad();
                            resolve();
                        } else {
                            console.warn(`‚ö†Ô∏è ANDROID DEBUG: ${globalVar} script loaded but global not found, trying CDN...`);
                            script.remove();
                            tryFallback();
                        }
                    }, 100);
                };
                
                script.onerror = (event) => {
                    clearTimeout(loadTimeout);
                    console.warn(`‚ö†Ô∏è ANDROID DEBUG: Local script load failed for ${globalVar}`);
                    console.warn(`   Failed URL: ${localPath}`);
                    console.warn(`   Error event:`, event);
                    console.warn(`   Trying CDN fallback: ${cdnPath}`);
                    script.remove();
                    tryFallback();
                };
                
                function tryFallback() {
                    const fallbackScript = document.createElement('script');
                    fallbackScript.src = cdnPath;
                    fallbackScript.type = 'text/javascript';
                    
                    const fallbackTimeout = setTimeout(() => {
                        console.error(`‚è∞ ANDROID DEBUG: CDN timeout for ${globalVar}`);
                        fallbackScript.remove();
                        window.libraryLoadingProgress[globalVar] = false;
                        reject(new Error(`Timeout loading ${globalVar} from CDN`));
                    }, 10000);
                    
                    fallbackScript.onload = () => {
                        clearTimeout(fallbackTimeout);
                        console.log(`‚úÖ ANDROID DEBUG: Script loaded for ${globalVar} from CDN:`, cdnPath);
                        
                        // Wait a moment for global variables to be set
                        setTimeout(() => {
                            if (validateLibraryLoaded(globalVar)) {
                                console.log(`‚úÖ ANDROID DEBUG: ${globalVar} CDN validated successfully`);
                                window.libraryLoadingProgress[globalVar] = true;
                                checkLibraryGlobals(globalVar);
                                if (onLoad) onLoad();
                                resolve();
                            } else {
                                console.error(`‚ùå ANDROID DEBUG: ${globalVar} CDN loaded but global still not found`);
                                window.libraryLoadingProgress[globalVar] = false;
                                reject(new Error(`${globalVar} global not available after CDN load`));
                            }
                        }, 100);
                    };
                    
                    fallbackScript.onerror = (event) => {
                        clearTimeout(fallbackTimeout);
                        console.error(`‚ùå ANDROID DEBUG: CDN script load failed for ${globalVar}`);
                        console.error(`   Local failed: ${localPath}`);
                        console.error(`   CDN failed: ${cdnPath}`);
                        console.error(`   CDN error event:`, event);
                        console.error(`   Current window.${globalVar}:`, typeof window[globalVar]);
                        window.libraryLoadingProgress[globalVar] = false;
                        reject(new Error(`Failed to load ${globalVar} from both local and CDN`));
                    };
                    
                    document.head.appendChild(fallbackScript);
                }
                
                document.head.appendChild(script);
            });
        }
        
        // Validate that a library actually loaded and set its global variables
        function validateLibraryLoaded(libraryName) {
            switch (libraryName) {
                case 'React':
                    return typeof window.React === 'object' && window.React !== null && typeof window.React.createElement === 'function';
                case 'ReactDOM':
                    return typeof window.ReactDOM === 'object' && window.ReactDOM !== null && typeof window.ReactDOM.createRoot === 'function';
                case 'THREE':
                    return typeof window.THREE === 'object' && window.THREE !== null && typeof window.THREE.Scene === 'function';
                case 'ReactThreeFiber':
                    // Check for our custom React Three Fiber implementation (basic check first)
                    const r3fValid = typeof window.ReactThreeFiber === 'object' &&
                           window.ReactThreeFiber !== null &&
                           typeof window.ReactThreeFiber.Canvas === 'function';
                    console.log('üîç ANDROID DEBUG: ReactThreeFiber validation:', {
                        exists: !!window.ReactThreeFiber,
                        Canvas: typeof window.ReactThreeFiber?.Canvas,
                        useFrame: typeof window.ReactThreeFiber?.useFrame,
                        useThree: typeof window.ReactThreeFiber?.useThree,
                        useLoader: typeof window.ReactThreeFiber?.useLoader,
                        valid: r3fValid
                    });
                    return r3fValid;
                case 'Drei':
                    // Check for our custom Drei implementation (basic check first)
                    const dreiValid = typeof window.Drei === 'object' &&
                           window.Drei !== null &&
                           typeof window.Drei.OrbitControls === 'function';
                    console.log('üîç ANDROID DEBUG: Drei validation:', {
                        exists: !!window.Drei,
                        OrbitControls: typeof window.Drei?.OrbitControls,
                        Box: typeof window.Drei?.Box,
                        Sphere: typeof window.Drei?.Sphere,
                        Environment: typeof window.Drei?.Environment,
                        valid: dreiValid
                    });
                    return dreiValid;
                default:
                    return false;
            }
        }

        // Expose to global scope for use in other script blocks
        window.validateLibraryLoaded = validateLibraryLoaded;
        
        function checkLibraryGlobals(libraryName) {
            const globals = {
                React: typeof window.React,
                ReactDOM: typeof window.ReactDOM,
                THREE: typeof window.THREE,
                ReactThreeFiber: typeof window.ReactThreeFiber,
                Drei: typeof window.Drei
            };
            console.log(`üîç ANDROID DEBUG: After loading ${libraryName}, globals:`, globals);
        }
        
        // Load all libraries sequentially to avoid conflicts
        async function loadAllLibraries() {
            console.log('üöÄ ANDROID DEBUG: Starting sequential library loading...');
            
            try {
                // Load React first with detailed progress
                console.log('üì¶ ANDROID DEBUG: Step 1/5 - Loading React...');
                await loadLibraryWithFallback(
                    'app://vendor/react-18.2.0.min.js',
                    'https://unpkg.com/react@18/umd/react.production.min.js',
                    'React'
                );
                console.log('‚úÖ ANDROID DEBUG: React loading completed');
                
                // Load ReactDOM
                console.log('üì¶ ANDROID DEBUG: Step 2/5 - Loading ReactDOM...');
                await loadLibraryWithFallback(
                    'app://vendor/react-dom-18.2.0.min.js',
                    'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js',
                    'ReactDOM'
                );
                console.log('‚úÖ ANDROID DEBUG: ReactDOM loading completed');
                
                // Load Three.js (use UMD build, not module)
                console.log('üì¶ ANDROID DEBUG: Step 3/5 - Loading Three.js...');
                await loadLibraryWithFallback(
                    'app://vendor/three-r160.module.js',
                    'https://unpkg.com/three@0.160.0/build/three.min.js',
                    'THREE'
                );
                console.log('‚úÖ ANDROID DEBUG: Three.js loading completed');
                
                // Since React Three Fiber and Drei don't provide UMD builds,
                // we'll load basic functionality and create mock globals
                console.log('‚ö†Ô∏è ANDROID DEBUG: React Three Fiber and Drei require ES modules - creating fallback globals');
                createReactThreeFiberGlobalsSync();  // Use sync version with reconciler
                createDreiGlobalsSync();
                
                console.log('‚úÖ ANDROID DEBUG: All libraries loading completed');
                librariesReady = true;

                // Globals already set up by createReactThreeFiberGlobals() and createDreiGlobals()
                console.log('‚úÖ ANDROID DEBUG: Library globals initialized');
                
            } catch (error) {
                console.error('‚ùå ANDROID DEBUG: Library loading failed:', error);
                // Try CDN-only fallback
                console.log('üîÑ ANDROID DEBUG: Attempting CDN-only fallback...');
                await loadLibrariesCDNOnly();
            }
        }
        
        // Fallback to load everything from CDN if local files fail
        async function loadLibrariesCDNOnly() {
            console.log('üåê ANDROID DEBUG: Loading all libraries from CDN only...');
            
            try {
                // Clear any partial loads
                delete window.React;
                delete window.ReactDOM;
                delete window.THREE;
                delete window.ReactThreeFiber;
                delete window.Drei;
                
                // Load React
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/react@18/umd/react.production.min.js';
                    script.onload = () => resolve();
                    script.onerror = () => reject(new Error('React CDN failed'));
                    document.head.appendChild(script);
                });
                
                // Load ReactDOM
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js';
                    script.onload = () => resolve();
                    script.onerror = () => reject(new Error('ReactDOM CDN failed'));
                    document.head.appendChild(script);
                });
                
                // Load THREE
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
                    script.onload = () => resolve();
                    script.onerror = () => reject(new Error('THREE CDN failed'));
                    document.head.appendChild(script);
                });
                
                // Wait for all basic libraries to settle
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Load React Three Fiber
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/@react-three/fiber@8.15.12/dist/index.js';
                    script.onload = () => resolve();
                    script.onerror = () => {
                        // Try alternative CDN
                        const altScript = document.createElement('script');
                        altScript.src = 'https://cdn.skypack.dev/@react-three/fiber@8';
                        altScript.onload = () => resolve();
                        altScript.onerror = () => reject(new Error('React Three Fiber CDN failed'));
                        document.head.appendChild(altScript);
                    };
                    document.head.appendChild(script);
                });
                
                // Load Drei
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/@react-three/drei@9.88.13/dist/index.js';
                    script.onload = () => resolve();
                    script.onerror = () => {
                        // Try alternative CDN
                        const altScript = document.createElement('script');
                        altScript.src = 'https://cdn.skypack.dev/@react-three/drei@9';
                        altScript.onload = () => resolve();
                        altScript.onerror = () => reject(new Error('Drei CDN failed'));
                        document.head.appendChild(altScript);
                    };
                    document.head.appendChild(script);
                });
                
                // Mark all as loaded
                window.libraryLoadingProgress = {
                    React: true,
                    ReactDOM: true,
                    THREE: true,
                    ReactThreeFiber: true,
                    Drei: true
                };
                
                librariesReady = true;
                console.log('‚úÖ ANDROID DEBUG: CDN-only loading completed');

                // Globals already set up by createReactThreeFiberGlobalsSync() and createDreiGlobalsSync()
                console.log('‚úÖ ANDROID DEBUG: Library globals initialized (CDN)');
                
            } catch (error) {
                console.error('‚ùå ANDROID DEBUG: CDN-only loading failed:', error);
            }
        }

        // Expose library loading functions to global scope
        window.loadAllLibraries = loadAllLibraries;
        window.loadLibrariesCDNOnly = loadLibrariesCDNOnly;

        // Create React Three Fiber globals synchronously
        function createReactThreeFiberGlobalsSync() {
            console.log('üîß ANDROID DEBUG: Creating React Three Fiber globals synchronously...');
            
            if (!window.React || !window.THREE) {
                console.error('‚ùå ANDROID DEBUG: React or THREE not available for R3F creation');
                console.error('   React:', typeof window.React);
                console.error('   THREE:', typeof window.THREE);
                return false;
            }
            
            try {
            
            // Global array for useFrame callbacks
            window.R3FFrameCallbacks = [];

            // Create a simplified React Three Fiber implementation
            window.ReactThreeFiber = {
                Canvas: function(props) {
                    // CRITICAL: Handle undefined props first, before any hooks
                    if (!props) props = {};

                    // CRITICAL: Hooks MUST be called unconditionally, OUTSIDE try-catch
                    const canvasRef = window.React.useRef();
                    const [sceneReady, setSceneReady] = window.React.useState(false);
                    const [error, setError] = window.React.useState(null);

                    console.log('üé® ANDROID DEBUG: Canvas component called with props:', props);
                    console.log('üîç ANDROID DEBUG: Canvas children:', props.children);
                    console.log('üîç ANDROID DEBUG: React hooks available:', {
                        useRef: typeof window.React.useRef,
                        useState: typeof window.React.useState,
                        useEffect: typeof window.React.useEffect
                    });
                    
                    window.React.useEffect(() => {
                        try {
                        if (!canvasRef.current) {
                            console.warn('‚ö†Ô∏è ANDROID DEBUG: Canvas ref not ready');
                            return;
                        }

                        console.log('üé® ANDROID DEBUG: Setting up Three.js canvas...');
                        console.log('üîç ANDROID DEBUG: Canvas dimensions:', {
                            width: canvasRef.current.clientWidth,
                            height: canvasRef.current.clientHeight
                        });

                        // Create Three.js scene
                        const scene = new window.THREE.Scene();

                        // CRITICAL FIX: Reduced default FOV from 75 to 60 degrees
                        // Narrower FOV prevents close objects (like sun) from appearing too large
                        // This provides better perspective for scenes with objects at varying distances
                        const fov = props.camera?.fov || 60;  // FIXED: Was 75, now 60
                        const camera = new window.THREE.PerspectiveCamera(
                            fov,
                            canvasRef.current.clientWidth / canvasRef.current.clientHeight,
                            0.1,
                            1000
                        );

                        if (props.camera?.position) {
                            camera.position.set(...props.camera.position);
                            console.log(`üì∑ ANDROID DEBUG: Camera position set to [${props.camera.position}] with FOV ${fov}`);
                        } else {
                            camera.position.set(0, 0, 5);
                            console.log(`üì∑ ANDROID DEBUG: Camera using default position [0, 0, 5] with FOV ${fov}`);
                        }
                        
                        const renderer = new window.THREE.WebGLRenderer({
                            canvas: canvasRef.current,
                            antialias: props.gl?.antialias !== false,
                            alpha: props.gl?.alpha || false
                        });
                        renderer.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);

                        // CRITICAL: Cap pixel ratio at 2 for mobile performance
                        // High-DPI Android devices can have devicePixelRatio of 3-4, which causes
                        // massive performance issues and can trigger automatic geometry reduction
                        const maxPixelRatio = 2;
                        const pixelRatio = Math.min(window.devicePixelRatio || 1, maxPixelRatio);
                        renderer.setPixelRatio(pixelRatio);
                        console.log(`üì± ANDROID DEBUG: Pixel ratio set to ${pixelRatio} (device: ${window.devicePixelRatio || 1})`);

                        renderer.setClearColor(0x000000, 1); // Black background for space

                        // CRITICAL: Configure renderer for realistic materials (meshStandardMaterial)
                        renderer.toneMapping = window.THREE.ACESFilmicToneMapping;
                        // CRITICAL FIX: Reduced tone mapping exposure from 1.0 to 0.6
                        // High exposure causes emissive objects (like sun) to bloom excessively and dominate the view
                        // Lower exposure provides better balance between emissive and non-emissive objects
                        renderer.toneMappingExposure = 0.6;  // FIXED: Was 1.0, now 0.6 to prevent sun bloom
                        renderer.outputEncoding = window.THREE.sRGBEncoding;

                        console.log('üé® ANDROID DEBUG: Tone mapping exposure set to 0.6 to prevent emissive bloom');

                        // Enable shadows for better visual quality
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = window.THREE.PCFSoftShadowMap;

                        // CRITICAL FIX: Configure WebGL for proper point rendering
                        // Mobile WebGL needs explicit point sprite configuration for PointsMaterial
                        const gl = renderer.getContext();
                        if (gl) {
                            // Enable point sprite rendering (for Stars component)
                            console.log('üé® ANDROID DEBUG: WebGL context capabilities:', {
                                maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                                maxPointSize: gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE),
                                vendor: gl.getParameter(gl.VENDOR),
                                renderer: gl.getParameter(gl.RENDERER)
                            });
                        }

                        console.log('‚úÖ ANDROID DEBUG: Renderer configured with tone mapping, sRGB encoding, and point sprite support');

                        // Create and store clock
                        if (!window.currentClock) {
                            window.currentClock = new window.THREE.Clock();
                        }

                        // Store references globally for child components
                        window.currentScene = scene;
                        window.currentCamera = camera;
                        window.currentRenderer = renderer;

                        console.log('‚úÖ ANDROID DEBUG: Three.js scene created and stored globally');
                        console.log('üîç ANDROID DEBUG: Scene type:', scene.type);
                        console.log('üîç ANDROID DEBUG: Camera position:', camera.position.x, camera.position.y, camera.position.z);
                        console.log('üîç ANDROID DEBUG: Renderer size:', renderer.getSize(new window.THREE.Vector2()));
                        
                        // Call onCreated callback if provided
                        if (props.onCreated) {
                            try {
                                props.onCreated({ gl: renderer, scene, camera });
                            } catch (error) {
                                console.error('‚ùå ANDROID DEBUG: onCreated callback error:', error);
                            }
                        }

                        // Scene will be built by React rendering children
                        console.log('‚ÑπÔ∏è ANDROID DEBUG: Scene ready, React will render children');
                        setSceneReady(true);

                        // Render loop with frame callbacks
                        let frameCount = 0;
                        let lastLogTime = Date.now();
                        let framesSinceLastLog = 0;

                        function animate() {
                            requestAnimationFrame(animate);
                            frameCount++;
                            framesSinceLastLog++;

                            const now = Date.now();
                            const timeSinceLastLog = now - lastLogTime;

                            // Log every 2 seconds with FPS calculation
                            if (timeSinceLastLog >= 2000) {
                                const fps = (framesSinceLastLog / timeSinceLastLog * 1000).toFixed(1);
                                console.log(`üé¨ ANDROID DEBUG: Frame ${frameCount} | FPS: ${fps} | useFrame callbacks: ${window.R3FFrameCallbacks.length} | scene objects: ${window.currentScene?.children.length || 0}`);

                                // Sample scene children types
                                if (window.currentScene && window.currentScene.children.length > 0) {
                                    const childTypes = {};
                                    window.currentScene.children.forEach(child => {
                                        const type = child.type || 'Unknown';
                                        childTypes[type] = (childTypes[type] || 0) + 1;
                                    });
                                    console.log('   üì¶ Scene objects:', childTypes);
                                }

                                lastLogTime = now;
                                framesSinceLastLog = 0;
                            }

                            // Call all registered useFrame callbacks
                            if (window.currentScene && window.currentCamera && window.currentRenderer && window.currentClock) {
                                const state = {
                                    scene: window.currentScene,
                                    camera: window.currentCamera,
                                    renderer: window.currentRenderer,
                                    clock: window.currentClock,
                                    gl: window.currentRenderer
                                };
                                const delta = window.currentClock.getDelta();

                                let callbackErrors = 0;
                                window.R3FFrameCallbacks.forEach((callback, index) => {
                                    try {
                                        callback(state, delta);
                                    } catch (error) {
                                        callbackErrors++;
                                        console.error(`‚ùå ANDROID DEBUG: useFrame callback #${index} error:`, error);
                                        console.error('   Error stack:', error.stack);
                                    }
                                });

                                // Log if there were callback errors this frame
                                if (callbackErrors > 0) {
                                    console.error(`‚ö†Ô∏è  ANDROID DEBUG: ${callbackErrors} useFrame callback errors in frame ${frameCount}`);
                                }
                            }

                            // Render the scene
                            if (window.currentScene && window.currentCamera && window.currentRenderer) {
                                window.currentRenderer.render(window.currentScene, window.currentCamera);
                            }
                        }
                        animate();

                        console.log('üöÄ ANDROID DEBUG: Animation loop started');

                        // Cleanup
                        return () => {
                            renderer.dispose();
                        };
                        } catch (err) {
                            console.error('‚ùå ANDROID DEBUG: Canvas setup error:', err);
                            setError(err);
                        }
                    }, []);

                    // Render error UI if there was an error
                    if (error) {
                        return window.React.createElement('div', {
                            style: {
                                width: '100%',
                                height: '100%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                color: 'white',
                                backgroundColor: '#1a1a2e'
                            }
                        }, 'Canvas Error: ' + error.message);
                    }

                    // Render canvas and children normally (React handles rendering)
                    console.log('üîÑ ANDROID DEBUG: Canvas component rendering JSX...');
                    const result = window.React.createElement('div', {
                        style: { width: '100%', height: '100%', position: 'relative', ...props.style }
                    },
                        window.React.createElement('canvas', {
                            ref: canvasRef,
                            style: { width: '100%', height: '100%', display: 'block' }
                        }),
                        // Render children normally - they'll create THREE.js objects via useEffect
                        sceneReady && props.children ? props.children : null
                    );
                    console.log('‚úÖ ANDROID DEBUG: Canvas JSX created successfully');
                    return result;
                },

                useFrame: function(callback) {
                    // Register callback in animation loop using useEffect
                    window.React.useEffect(() => {
                        // Create a wrapper to track callback execution
                        let executionCount = 0;
                        const callbackId = Math.random().toString(36).substr(2, 9);

                        const wrappedCallback = (state, delta) => {
                            executionCount++;

                            // Log first 3 executions for debugging
                            if (executionCount <= 3) {
                                console.log(`üé¨ ANDROID DEBUG: useFrame callback #${callbackId} execution ${executionCount}`);
                            }

                            try {
                                callback(state, delta);
                            } catch (error) {
                                console.error(`‚ùå ANDROID DEBUG: useFrame callback #${callbackId} error:`, error);
                                throw error; // Re-throw to be caught by animation loop
                            }
                        };

                        console.log(`üé¨ ANDROID DEBUG: useFrame callback #${callbackId} registered (total: ${window.R3FFrameCallbacks.length + 1})`);
                        window.R3FFrameCallbacks.push(wrappedCallback);

                        // Cleanup - remove callback when component unmounts
                        return () => {
                            const index = window.R3FFrameCallbacks.indexOf(wrappedCallback);
                            if (index > -1) {
                                window.R3FFrameCallbacks.splice(index, 1);
                                console.log(`üé¨ ANDROID DEBUG: useFrame callback #${callbackId} removed (executed ${executionCount} times, remaining: ${window.R3FFrameCallbacks.length})`);
                            }
                        };
                    }, [callback]);
                },

                useThree: function() {
                    return {
                        scene: window.currentScene,
                        camera: window.currentCamera,
                        renderer: window.currentRenderer
                    };
                }
            };
            
            // Add useLoader functionality
            window.ReactThreeFiber.useLoader = function(loader, url) {
                const [resource, setResource] = window.React.useState(null);

                window.React.useEffect(() => {
                    if (!loader || !url) return;

                    try {
                        const loaderInstance = new loader();
                        loaderInstance.load(url, (result) => {
                            setResource(result);
                        });
                    } catch (err) {
                        console.error('useLoader error:', err);
                    }
                }, [loader, url]);

                return resource;
            };

            // ========================================
            // R3F PRIMITIVE COMPONENTS
            // ========================================

            // ========================================
            // DECLARATIVE-TO-IMPERATIVE RECONCILER
            // ========================================
            // Build THREE.js scene from React element tree
            window.R3FSceneBuilder = {
                build: function(elementTree, scene) {
                    console.log('üî® ANDROID DEBUG: Building THREE.js scene from React elements...');

                    const objects = [];

                    function processElement(element, parent = scene) {
                        if (!element || typeof element !== 'object') return null;

                        // Handle arrays of elements
                        if (Array.isArray(element)) {
                            element.forEach(el => processElement(el, parent));
                            return null;
                        }

                        const type = element.type;
                        const props = element.props || {};
                        const children = props.children;

                        console.log(`üîß Processing element type:`, type?.name || type, props);

                        // Skip if not a function/component
                        if (!type) return null;

                        const typeName = type.name || (typeof type === 'string' ? type : null);

                        // Handle geometry (case-insensitive check)
                        if (typeName && typeName.toLowerCase().includes('geometry')) {
                            const args = props.args || [];
                            const className = typeName.charAt(0).toUpperCase() + typeName.slice(1);
                            console.log(`üîß Creating geometry: ${typeName} -> THREE.${className} with args:`, args);
                            const GeometryClass = window.THREE[className];
                            if (GeometryClass) {
                                const geometry = new GeometryClass(...args);
                                console.log(`‚úÖ Created ${typeName}`, geometry);
                                return { type: 'geometry', object: geometry };
                            } else {
                                console.error(`‚ùå THREE.${className} not found`);
                            }
                        }

                        // Handle materials (case-insensitive check)
                        if (typeName && typeName.toLowerCase().includes('material')) {
                            const materialProps = { ...props };
                            delete materialProps.args;
                            delete materialProps.children;

                            const className = typeName.charAt(0).toUpperCase() + typeName.slice(1);
                            console.log(`üîß Creating material: ${typeName} -> THREE.${className} with props:`, materialProps);
                            const MaterialClass = window.THREE[className];
                            if (MaterialClass) {
                                const material = new MaterialClass(materialProps);
                                console.log(`‚úÖ Created ${typeName}`, material);
                                return { type: 'material', object: material };
                            } else {
                                console.error(`‚ùå THREE.${className} not found`);
                            }
                        }

                        // Handle lights (case-insensitive check)
                        if (typeName && typeName.toLowerCase().includes('light')) {
                            const args = props.args || [];
                            const className = typeName.charAt(0).toUpperCase() + typeName.slice(1);
                            console.log(`üîß Creating light: ${typeName} -> THREE.${className} with args:`, args);
                            const LightClass = window.THREE[className];
                            if (LightClass) {
                                const light = new LightClass(...args);
                                if (props.position) light.position.set(...props.position);
                                if (props.intensity !== undefined) light.intensity = props.intensity;
                                if (props.color) light.color.set(props.color);

                                parent.add(light);
                                console.log(`‚úÖ Added ${typeName} to scene`, light);
                                objects.push(light);
                                return light;
                            } else {
                                console.error(`‚ùå THREE.${className} not found`);
                            }
                        }

                        // Handle mesh
                        if (typeName === 'mesh') {
                            console.log(`üîß Creating mesh with props:`, props);
                            let geometry = null;
                            let material = null;

                            // Process children to find geometry and material
                            if (children) {
                                const childArray = Array.isArray(children) ? children : [children];
                                console.log(`üîç Processing ${childArray.length} mesh children...`);
                                childArray.forEach(child => {
                                    const result = processElement(child, parent);
                                    if (result?.type === 'geometry') {
                                        geometry = result.object;
                                        console.log(`   ‚úì Found geometry for mesh`);
                                    }
                                    if (result?.type === 'material') {
                                        material = result.object;
                                        console.log(`   ‚úì Found material for mesh`);
                                    }
                                });
                            }

                            const mesh = new window.THREE.Mesh(geometry, material);
                            if (props.position) {
                                mesh.position.set(...props.position);
                                console.log(`   ‚úì Set mesh position:`, props.position);
                            }
                            if (props.rotation) {
                                mesh.rotation.set(...props.rotation);
                                console.log(`   ‚úì Set mesh rotation:`, props.rotation);
                            }
                            if (props.scale) {
                                if (Array.isArray(props.scale)) {
                                    mesh.scale.set(...props.scale);
                                } else {
                                    mesh.scale.setScalar(props.scale);
                                }
                                console.log(`   ‚úì Set mesh scale:`, props.scale);
                            }

                            parent.add(mesh);
                            console.log(`‚úÖ Added mesh to scene`, mesh);
                            objects.push(mesh);
                            return mesh;
                        }

                        // Handle group
                        if (typeName === 'group') {
                            const group = new window.THREE.Group();
                            if (props.position) group.position.set(...props.position);
                            if (props.rotation) group.rotation.set(...props.rotation);

                            parent.add(group);
                            objects.push(group);

                            // Process children with group as parent
                            if (children) {
                                const childArray = Array.isArray(children) ? children : [children];
                                childArray.forEach(child => processElement(child, group));
                            }

                            console.log(`‚úÖ Added group to scene`, group);
                            return group;
                        }

                        // Handle line/lineSegments
                        if (typeName === 'line' || typeName === 'lineSegments') {
                            let geometry = null;
                            let material = null;

                            if (children) {
                                const childArray = Array.isArray(children) ? children : [children];
                                childArray.forEach(child => {
                                    const result = processElement(child, parent);
                                    if (result?.type === 'geometry') geometry = result.object;
                                    if (result?.type === 'material') material = result.object;
                                });
                            }

                            const LineClass = typeName === 'lineSegments' ? window.THREE.LineSegments : window.THREE.Line;
                            const line = new LineClass(geometry, material);

                            parent.add(line);
                            console.log(`‚úÖ Added ${typeName} to scene`, line);
                            objects.push(line);
                            return line;
                        }

                        // Handle points
                        if (typeName === 'points') {
                            let geometry = props.geometry || null;
                            let material = null;

                            if (children && !geometry) {
                                const childArray = Array.isArray(children) ? children : [children];
                                childArray.forEach(child => {
                                    const result = processElement(child, parent);
                                    if (result?.type === 'geometry') geometry = result.object;
                                    if (result?.type === 'material') material = result.object;
                                });
                            }

                            const points = new window.THREE.Points(geometry, material);
                            parent.add(points);
                            console.log(`‚úÖ Added points to scene`, points);
                            objects.push(points);
                            return points;
                        }

                        // Handle instancedMesh
                        if (typeName === 'instancedMesh') {
                            let geometry = null;
                            let material = null;
                            const args = props.args || [];
                            const count = args[2] || 1;

                            if (children) {
                                const childArray = Array.isArray(children) ? children : [children];
                                childArray.forEach(child => {
                                    const result = processElement(child, parent);
                                    if (result?.type === 'geometry') geometry = result.object;
                                    if (result?.type === 'material') material = result.object;
                                });
                            }

                            const instancedMesh = new window.THREE.InstancedMesh(geometry, material, count);

                            if (props.position) instancedMesh.position.set(...props.position);
                            if (props.rotation) instancedMesh.rotation.set(...props.rotation);
                            if (props.scale) {
                                if (Array.isArray(props.scale)) {
                                    instancedMesh.scale.set(...props.scale);
                                } else {
                                    instancedMesh.scale.setScalar(props.scale);
                                }
                            }

                            parent.add(instancedMesh);
                            console.log(`‚úÖ Added instancedMesh to scene (count: ${count})`, instancedMesh);
                            objects.push(instancedMesh);
                            return instancedMesh;
                        }

                        // Handle color (background)
                        if (typeName === 'color' && props.attach === 'background') {
                            const color = new window.THREE.Color(props.args?.[0] || '#000000');
                            scene.background = color;
                            console.log(`‚úÖ Set scene background color`, color);
                            return null;
                        }

                        // Handle helpers (gridHelper, axesHelper, etc.)
                        if (typeName && typeName.toLowerCase().includes('helper')) {
                            const args = props.args || [];
                            const className = typeName.charAt(0).toUpperCase() + typeName.slice(1);
                            console.log(`üîß Creating helper: ${typeName} -> THREE.${className} with args:`, args);
                            const HelperClass = window.THREE[className];
                            if (HelperClass) {
                                const helper = new HelperClass(...args);
                                if (props.position) helper.position.set(...props.position);
                                parent.add(helper);
                                console.log(`‚úÖ Added ${typeName} to scene`, helper);
                                objects.push(helper);
                                return helper;
                            } else {
                                console.error(`‚ùå THREE.${className} not found`);
                            }
                        }

                        // Handle custom React components (functions)
                        // Custom components should use useEffect to add objects to scene
                        // We just recursively process their children if they have any
                        if (typeof type === 'function') {
                            console.log(`‚ÑπÔ∏è Skipping custom component: ${typeName} (should use useEffect to add objects)`);
                            // Process children if any
                            if (children) {
                                const childArray = Array.isArray(children) ? children : [children];
                                childArray.forEach(child => processElement(child, parent));
                            }
                            return null;
                        }

                        // Recursively process children for other components
                        if (children) {
                            const childArray = Array.isArray(children) ? children : [children];
                            childArray.forEach(child => processElement(child, parent));
                        }

                        return null;
                    }

                    processElement(elementTree, scene);

                    console.log(`‚úÖ ANDROID DEBUG: Scene built with ${objects.length} objects`);
                    return objects;
                }
            };

            // Parent context for THREE.js object hierarchy
            const ParentContext = window.React.createContext(null);

            // Primitive components - create THREE.js objects on mount using useEffect (iOS approach)
            function createPrimitive(name, ThreeClass, isGeometry = false, isMaterial = false, isLight = false) {
                const component = function(props) {
                    console.log(`üé® ANDROID DEBUG: ${name} component rendering`);

                    const objectRef = window.React.useRef(null);
                    const meshContext = window.React.useContext(MeshContext);
                    const lineContext = window.React.useContext(LineContext);
                    const pointsContext = window.React.useContext(PointsContext);
                    const parentObject = window.React.useContext(ParentContext);

                    window.React.useEffect(() => {
                        console.log(`üî® ANDROID DEBUG: ${name} useEffect running with props:`, props, {
                            hasParent: !!parentObject
                        });

                        if (!window.currentScene && !isGeometry && !isMaterial) {
                            console.warn(`‚ö†Ô∏è ANDROID DEBUG: Scene not ready for ${name}`);
                            return;
                        }

                        try {
                            let threeObject;

                            // Geometry components
                            if (isGeometry) {
                                const args = props.args || [];
                                console.log(`üîç ANDROID DEBUG: ${name} creating geometry with args:`, JSON.stringify(args), `(${args.length} params)`);
                                threeObject = new ThreeClass(...args);

                                // Log what was actually created
                                if (threeObject.parameters) {
                                    console.log(`‚úÖ ANDROID DEBUG: ${name} geometry created successfully`);
                                    console.log(`   üìä Radius: ${threeObject.parameters.radius}, Width segments: ${threeObject.parameters.widthSegments}, Height segments: ${threeObject.parameters.heightSegments}`);
                                } else {
                                    console.log(`‚úÖ ANDROID DEBUG: ${name} geometry created (no parameters property)`);
                                }

                                // CRITICAL: Ensure smooth shading by computing vertex normals
                                // Some Android WebView environments may not auto-compute normals
                                if (threeObject.computeVertexNormals && typeof threeObject.computeVertexNormals === 'function') {
                                    threeObject.computeVertexNormals();
                                    console.log(`üîß ANDROID DEBUG: ${name} vertex normals computed for smooth shading`);
                                }

                                objectRef.current = threeObject;

                                // Register with parent mesh, line, or points via context
                                if (meshContext && meshContext.registerGeometry) {
                                    meshContext.registerGeometry(threeObject);
                                } else if (lineContext && lineContext.registerGeometry) {
                                    lineContext.registerGeometry(threeObject);
                                } else if (pointsContext && pointsContext.registerGeometry) {
                                    pointsContext.registerGeometry(threeObject);
                                } else {
                                    console.warn(`‚ö†Ô∏è ANDROID DEBUG: ${name} has no parent mesh/line/points context`);
                                }
                                return;
                            }

                            // Material components
                            if (isMaterial) {
                                const materialProps = { ...props };
                                delete materialProps.args;
                                delete materialProps.children;

                                // CRITICAL: Explicitly set smooth shading for all materials
                                // Without this, materials may default to flat shading on some platforms
                                if (materialProps.flatShading === undefined) {
                                    materialProps.flatShading = false; // Ensure smooth shading
                                }

                                threeObject = new ThreeClass(materialProps);

                                // CRITICAL: Force material update to apply smooth shading
                                // This ensures the material shader is recompiled with correct shading mode
                                threeObject.needsUpdate = true;

                                console.log(`‚úÖ ANDROID DEBUG: ${name} material created with flatShading=${threeObject.flatShading}`);
                                console.log(`   üé® Material properties: color=${threeObject.color ? threeObject.color.getHexString() : 'none'}, emissive=${threeObject.emissive ? threeObject.emissive.getHexString() : 'none'}, emissiveIntensity=${threeObject.emissiveIntensity}, roughness=${threeObject.roughness}, metalness=${threeObject.metalness}`);
                                objectRef.current = threeObject;

                                // Register with parent mesh, line, or points via context
                                if (meshContext && meshContext.registerMaterial) {
                                    meshContext.registerMaterial(threeObject);
                                } else if (lineContext && lineContext.registerMaterial) {
                                    lineContext.registerMaterial(threeObject);
                                } else if (pointsContext && pointsContext.registerMaterial) {
                                    pointsContext.registerMaterial(threeObject);
                                } else {
                                    console.warn(`‚ö†Ô∏è ANDROID DEBUG: ${name} has no parent mesh/line/points context`);
                                }
                                return;
                            }

                            // Lights and other objects (line, points, etc.)
                            const args = props.args || [];

                            // For Line/Points, they may have geometry/material passed as props
                            if (props.geometry || props.material) {
                                const geometry = props.geometry || args[0];
                                const material = props.material || args[1];
                                threeObject = new ThreeClass(geometry, material);
                            } else {
                                threeObject = new ThreeClass(...args);
                            }

                            // Apply common properties
                            if (props.position) threeObject.position.set(...props.position);
                            if (props.rotation) threeObject.rotation.set(...props.rotation);
                            if (props.scale) {
                                if (Array.isArray(props.scale)) {
                                    threeObject.scale.set(...props.scale);
                                } else {
                                    threeObject.scale.setScalar(props.scale);
                                }
                            }
                            if (props.intensity !== undefined && threeObject.intensity !== undefined) {
                                threeObject.intensity = props.intensity;
                            }
                            if (props.color && threeObject.color) {
                                threeObject.color.set(props.color);
                            }

                            // ENHANCED: Better logging for lights to diagnose visibility issues
                            if (isLight) {
                                console.log(`üí° ANDROID DEBUG: ${name} configured -`, {
                                    intensity: threeObject.intensity,
                                    color: threeObject.color ? `#${threeObject.color.getHexString()}` : 'none',
                                    position: threeObject.position ? `[${threeObject.position.x.toFixed(2)}, ${threeObject.position.y.toFixed(2)}, ${threeObject.position.z.toFixed(2)}]` : 'default',
                                    type: name
                                });
                            }

                            // Store ref if provided
                            if (props.ref) {
                                props.ref.current = threeObject;
                            }

                            // Add to parent object or scene
                            const targetParent = (parentObject && parentObject.current) || window.currentScene;
                            targetParent.add(threeObject);
                            console.log(`‚úÖ ANDROID DEBUG: ${name} added to ${(parentObject && parentObject.current) ? 'parent object' : 'scene'}`, threeObject);
                            objectRef.current = threeObject;

                            // Cleanup function
                            return () => {
                                if (objectRef.current) {
                                    const currentParent = (parentObject && parentObject.current) || window.currentScene;
                                    if (currentParent) {
                                        currentParent.remove(objectRef.current);
                                    }
                                    if (objectRef.current.geometry) objectRef.current.geometry.dispose();
                                    if (objectRef.current.material) {
                                        if (Array.isArray(objectRef.current.material)) {
                                            objectRef.current.material.forEach(m => m.dispose());
                                        } else {
                                            objectRef.current.material.dispose();
                                        }
                                    }
                                    console.log(`üóëÔ∏è ANDROID DEBUG: ${name} cleaned up`);
                                }
                            };
                        } catch (error) {
                            console.error(`‚ùå ANDROID DEBUG: Error creating ${name}:`, error);
                        }
                    }, []); // Empty deps - create once on mount

                    // Provide this object ref as parent context for children
                    // Children will access objectRef.current in their useEffect
                    // This allows children to add themselves to this object instead of the scene
                    return window.React.createElement(
                        ParentContext.Provider,
                        { value: objectRef },
                        props.children
                    );
                };

                Object.defineProperty(component, 'name', {
                    value: name,
                    writable: false
                });

                return component;
            }

            // OLD CONTEXT-BASED APPROACH - REMOVED
            // Helper to create a component that builds THREE.js objects
            function createPrimitive_OLD(name, ThreeClass, isGeometry = false, isMaterial = false, isLight = false) {
                return function(props) {
                    console.log(`üèóÔ∏è ANDROID DEBUG: ${name} component function called with props:`, props);

                    const objectRef = window.React.useRef();
                    const geometryRef = window.React.useRef(null);
                    const materialRef = window.React.useRef(null);

                    window.React.useEffect(() => {
                        console.log(`üî® ANDROID DEBUG: ${name} useEffect running...`, props);

                        if (!window.currentScene) {
                            console.warn(`‚ö†Ô∏è ANDROID DEBUG: Scene not ready for ${name}`);
                            return;
                        }

                        try {
                            let threeObject;

                            // Geometry components
                            if (isGeometry) {
                                const args = props.args || [];
                                threeObject = new ThreeClass(...args);
                                console.log(`‚úÖ ANDROID DEBUG: ${name} geometry created`, threeObject);
                                objectRef.current = threeObject;

                                // Attach to parent mesh
                                if (context.attachGeometry) {
                                    context.attachGeometry(threeObject);
                                }
                                return;
                            }

                            // Material components
                            if (isMaterial) {
                                const materialProps = { ...props };
                                delete materialProps.args;
                                delete materialProps.children;

                                threeObject = new ThreeClass(materialProps);
                                console.log(`‚úÖ ANDROID DEBUG: ${name} material created`, threeObject);
                                objectRef.current = threeObject;

                                // Attach to parent mesh
                                if (context.attachMaterial) {
                                    context.attachMaterial(threeObject);
                                }
                                return;
                            }

                            // Light components
                            if (isLight) {
                                const args = props.args || [];
                                threeObject = new ThreeClass(...args);

                                // Apply light properties
                                if (props.position) threeObject.position.set(...props.position);
                                if (props.intensity !== undefined) threeObject.intensity = props.intensity;
                                if (props.color !== undefined) threeObject.color.set(props.color);

                                window.currentScene.add(threeObject);
                                objectRef.current = threeObject;
                                console.log(`‚úÖ ANDROID DEBUG: ${name} light added to scene`, threeObject);

                                return () => {
                                    window.currentScene.remove(threeObject);
                                };
                            }

                            // Object primitives (mesh, group, points, etc.)
                            // For mesh, we need to wait for geometry and material from children
                            // We'll create the mesh in a separate effect after children render

                        } catch (error) {
                            console.error(`‚ùå ANDROID DEBUG: Error creating ${name}:`, error);
                        }
                    }, [props, context]);

                    // Separate effect for mesh creation after geometry/material are attached
                    window.React.useEffect(() => {
                        if (isGeometry || isMaterial || isLight) return; // Skip for non-object primitives

                        console.log(`üî® ANDROID DEBUG: Setting up ${name} with geometry/material...`);

                        // For mesh: wait a tick to let children attach geometry/material
                        const timer = setTimeout(() => {
                            try {
                                let threeObject;

                                if (name === 'mesh') {
                                    // Create mesh with geometry and material from children
                                    threeObject = new window.THREE.Mesh(geometryRef.current, materialRef.current);
                                    console.log(`‚úÖ ANDROID DEBUG: Mesh created with`, {
                                        geometry: geometryRef.current,
                                        material: materialRef.current
                                    });
                                } else {
                                    // Other primitives (group, points, etc.)
                                    threeObject = new ThreeClass();
                                }

                                // Apply transform properties
                                if (props.position && Array.isArray(props.position)) {
                                    threeObject.position.set(...props.position);
                                }
                                if (props.rotation && Array.isArray(props.rotation)) {
                                    threeObject.rotation.set(...props.rotation);
                                }
                                if (props.scale) {
                                    if (Array.isArray(props.scale)) {
                                        threeObject.scale.set(...props.scale);
                                    } else if (typeof props.scale === 'number') {
                                        threeObject.scale.setScalar(props.scale);
                                    }
                                }

                                objectRef.current = threeObject;

                                // Add to scene
                                window.currentScene.add(threeObject);
                                console.log(`‚úÖ ANDROID DEBUG: ${name} added to scene`, threeObject);

                            } catch (error) {
                                console.error(`‚ùå ANDROID DEBUG: Error creating ${name}:`, error);
                            }
                        }, 10); // Small delay to let children render first

                        return () => {
                            clearTimeout(timer);
                            if (objectRef.current && window.currentScene) {
                                window.currentScene.remove(objectRef.current);
                                if (objectRef.current.geometry) objectRef.current.geometry.dispose();
                                if (objectRef.current.material) objectRef.current.material.dispose();
                            }
                        };
                    }, [geometryRef.current, materialRef.current, props]);

                    // Expose ref to props.ref if provided
                    window.React.useEffect(() => {
                        if (props.ref && typeof props.ref === 'object') {
                            props.ref.current = objectRef.current;
                        }
                    }, [objectRef.current, props.ref]);

                    // Render children with context for geometry/material attachment
                    if (props.children) {
                        return window.React.createElement(
                            R3FContext.Provider,
                            { value: { parent: objectRef.current, attachGeometry, attachMaterial } },
                            props.children
                        );
                    }

                    return null;
                };
            }

            // Create React Context for parent-child communication (geometry/material attachment)
            const MeshContext = window.React.createContext(null);

            // Special mesh component that handles geometry and material children
            window.ReactThreeFiber.mesh = function(props) {
                console.log('üé® ANDROID DEBUG: mesh component rendering');

                const meshRef = window.React.useRef(null);
                const geometryRef = window.React.useRef(null);
                const materialRef = window.React.useRef(null);
                const meshCreatedRef = window.React.useRef(false);

                // Function to create mesh when both geometry and material are ready
                // Use useCallback to ensure stable reference
                const tryCreateMesh = window.React.useCallback(() => {
                    // Prevent creating mesh multiple times
                    if (meshCreatedRef.current) {
                        console.log('‚è≠Ô∏è  ANDROID DEBUG: Mesh already created, skipping');
                        return;
                    }

                    // Check if both geometry and material are registered
                    if (!geometryRef.current || !materialRef.current) {
                        console.log('‚è≥ ANDROID DEBUG: Waiting for geometry/material...', {
                            hasGeometry: !!geometryRef.current,
                            hasMaterial: !!materialRef.current
                        });
                        return;
                    }

                    if (!window.currentScene) {
                        console.warn('‚ö†Ô∏è ANDROID DEBUG: Scene not ready for mesh');
                        return;
                    }

                    try {
                        console.log('üî® ANDROID DEBUG: Creating THREE.Mesh with:');
                        console.log('   üìê Geometry:', geometryRef.current.type);
                        if (geometryRef.current.parameters) {
                            console.log(`   üìä Geometry params - Radius: ${geometryRef.current.parameters.radius}, Segments: ${geometryRef.current.parameters.widthSegments}x${geometryRef.current.parameters.heightSegments}`);
                        }
                        console.log('   üé® Material:', materialRef.current.type);
                        console.log(`   ‚ú® Material smooth shading: ${materialRef.current.flatShading === false ? 'YES' : 'NO'} (flatShading=${materialRef.current.flatShading})`);
                        if (materialRef.current.color) {
                            console.log(`   üåà Material color: #${materialRef.current.color.getHexString()} (emissive: #${materialRef.current.emissive ? materialRef.current.emissive.getHexString() : '000000'})`);
                        }
                        console.log('   üìç Position:', props.position);

                        const mesh = new window.THREE.Mesh(geometryRef.current, materialRef.current);

                        // Apply properties BEFORE adding to scene
                        if (props.position) {
                            mesh.position.set(...props.position);
                            console.log('üìç ANDROID DEBUG: Set mesh position:', mesh.position);
                        }
                        if (props.rotation) {
                            mesh.rotation.set(...props.rotation);
                        }
                        if (props.scale) {
                            if (Array.isArray(props.scale)) {
                                mesh.scale.set(...props.scale);
                            } else {
                                mesh.scale.setScalar(props.scale);
                            }
                        }

                        // Set BOTH refs BEFORE adding to scene
                        meshRef.current = mesh;
                        if (props.ref) {
                            props.ref.current = mesh;
                            console.log('‚úÖ ANDROID DEBUG: Set props.ref.current to mesh');
                        }

                        // Add to scene
                        window.currentScene.add(mesh);
                        meshCreatedRef.current = true;

                        console.log('‚úÖ ANDROID DEBUG: mesh added to scene with ID:', mesh.uuid);
                        console.log('üîç ANDROID DEBUG: Total scene children:', window.currentScene.children.length);
                    } catch (error) {
                        console.error('‚ùå ANDROID DEBUG: Error creating mesh:', error);
                    }
                }, [props.position, props.rotation, props.scale, props.ref]);

                // Context value for children to register their geometry/material
                const contextValue = window.React.useMemo(() => ({
                    registerGeometry: (geo) => {
                        console.log('üìê ANDROID DEBUG: Geometry registered with mesh', geo.type);
                        geometryRef.current = geo;
                        // Use setTimeout to ensure we're not in the middle of a render
                        setTimeout(() => tryCreateMesh(), 0);
                    },
                    registerMaterial: (mat) => {
                        console.log('üé® ANDROID DEBUG: Material registered with mesh', mat.type);
                        materialRef.current = mat;
                        // Use setTimeout to ensure we're not in the middle of a render
                        setTimeout(() => tryCreateMesh(), 0);
                    }
                }), [tryCreateMesh]);

                // Cleanup on unmount
                window.React.useEffect(() => {
                    return () => {
                        if (meshRef.current && window.currentScene) {
                            window.currentScene.remove(meshRef.current);
                            if (meshRef.current.geometry) meshRef.current.geometry.dispose();
                            if (meshRef.current.material) {
                                if (Array.isArray(meshRef.current.material)) {
                                    meshRef.current.material.forEach(m => m.dispose());
                                } else {
                                    meshRef.current.material.dispose();
                                }
                            }
                            console.log('üóëÔ∏è ANDROID DEBUG: mesh cleaned up');
                        }
                    };
                }, []);

                // Render children within context so they can register themselves
                // Also provide ParentContext so non-geometry/material children can be added to this mesh
                return window.React.createElement(
                    ParentContext.Provider,
                    { value: meshRef },
                    window.React.createElement(
                        MeshContext.Provider,
                        { value: contextValue },
                        props.children
                    )
                );
            };

            // Create React Context for line parent-child communication (material attachment)
            const LineContext = window.React.createContext(null);

            // Special line component that handles geometry and material from children OR props
            window.ReactThreeFiber.line = function(props) {
                console.log('üé® ANDROID DEBUG: line component rendering');

                const lineRef = window.React.useRef(null);
                const geometryRef = window.React.useRef(null);
                const materialRef = window.React.useRef(null);
                const lineCreatedRef = window.React.useRef(false);

                // Function to create line when geometry and material are ready
                // Use useCallback to ensure stable reference
                const tryCreateLine = window.React.useCallback(() => {
                    // Prevent creating line multiple times
                    if (lineCreatedRef.current) {
                        console.log('‚è≠Ô∏è  ANDROID DEBUG: Line already created, skipping');
                        return;
                    }

                    // Get geometry from props OR from child registration
                    const geometry = props.geometry || geometryRef.current;
                    const material = materialRef.current;

                    // Check if both geometry and material are ready
                    if (!geometry || !material) {
                        console.log('‚è≥ ANDROID DEBUG: line waiting for geometry/material...', {
                            hasGeometry: !!geometry,
                            hasMaterial: !!material
                        });
                        return;
                    }

                    if (!window.currentScene) {
                        console.warn('‚ö†Ô∏è ANDROID DEBUG: Scene not ready for line');
                        return;
                    }

                    try {
                        console.log('üî® ANDROID DEBUG: Creating THREE.Line with:', {
                            geometry: geometry.type,
                            material: material.type,
                            position: props.position
                        });

                        const line = new window.THREE.Line(geometry, material);

                        // Apply properties BEFORE adding to scene
                        if (props.position) {
                            line.position.set(...props.position);
                            console.log('üìç ANDROID DEBUG: Set line position:', line.position);
                        }
                        if (props.rotation) {
                            line.rotation.set(...props.rotation);
                        }
                        if (props.scale) {
                            if (Array.isArray(props.scale)) {
                                line.scale.set(...props.scale);
                            } else {
                                line.scale.setScalar(props.scale);
                            }
                        }

                        // Set BOTH refs BEFORE adding to scene
                        lineRef.current = line;
                        if (props.ref) {
                            props.ref.current = line;
                            console.log('‚úÖ ANDROID DEBUG: Set props.ref.current to line');
                        }

                        // Add to scene
                        window.currentScene.add(line);
                        lineCreatedRef.current = true;

                        console.log('‚úÖ ANDROID DEBUG: line added to scene with ID:', line.uuid);
                        console.log('üîç ANDROID DEBUG: Total scene children:', window.currentScene.children.length);
                    } catch (error) {
                        console.error('‚ùå ANDROID DEBUG: Error creating line:', error);
                    }
                }, [props.geometry, props.position, props.rotation, props.scale, props.ref]);

                // Context value for children to register their geometry/material
                const contextValue = window.React.useMemo(() => ({
                    registerGeometry: (geo) => {
                        console.log('üìê ANDROID DEBUG: Geometry registered with line', geo.type);
                        geometryRef.current = geo;
                        // Use setTimeout to ensure we're not in the middle of a render
                        setTimeout(() => tryCreateLine(), 0);
                    },
                    registerMaterial: (mat) => {
                        console.log('üé® ANDROID DEBUG: Material registered with line', mat.type);
                        materialRef.current = mat;
                        // Use setTimeout to ensure we're not in the middle of a render
                        setTimeout(() => tryCreateLine(), 0);
                    }
                }), [tryCreateLine]);

                // Cleanup on unmount
                window.React.useEffect(() => {
                    return () => {
                        if (lineRef.current && window.currentScene) {
                            window.currentScene.remove(lineRef.current);
                            if (lineRef.current.geometry) lineRef.current.geometry.dispose();
                            if (lineRef.current.material) {
                                if (Array.isArray(lineRef.current.material)) {
                                    lineRef.current.material.forEach(m => m.dispose());
                                } else {
                                    lineRef.current.material.dispose();
                                }
                            }
                            console.log('üóëÔ∏è ANDROID DEBUG: line cleaned up');
                        }
                    };
                }, []);

                // Render children within context so they can register themselves
                // Also provide ParentContext so non-geometry/material children can be added to this line
                return window.React.createElement(
                    ParentContext.Provider,
                    { value: lineRef },
                    window.React.createElement(
                        LineContext.Provider,
                        { value: contextValue },
                        props.children
                    )
                );
            };

            // Create React Context for points parent-child communication (material attachment)
            const PointsContext = window.React.createContext(null);

            // Special points component that handles geometry and material from children OR props
            window.ReactThreeFiber.points = function(props) {
                console.log('‚≠ê ANDROID DEBUG: points component rendering');

                const pointsRef = window.React.useRef(null);
                const geometryRef = window.React.useRef(null);
                const materialRef = window.React.useRef(null);
                const pointsCreatedRef = window.React.useRef(false);

                // Function to create points when geometry and material are ready
                // Use useCallback to ensure stable reference
                const tryCreatePoints = window.React.useCallback(() => {
                    // Prevent creating points multiple times
                    if (pointsCreatedRef.current) {
                        console.log('‚è≠Ô∏è  ANDROID DEBUG: Points already created, skipping');
                        return;
                    }

                    // Get geometry from props OR from child registration
                    const geometry = props.geometry || geometryRef.current;
                    const material = materialRef.current;

                    // Check if both geometry and material are ready
                    if (!geometry || !material) {
                        console.log('‚è≥ ANDROID DEBUG: points waiting for geometry/material...', {
                            hasGeometry: !!geometry,
                            hasMaterial: !!material
                        });
                        return;
                    }

                    if (!window.currentScene) {
                        console.warn('‚ö†Ô∏è ANDROID DEBUG: Scene not ready for points');
                        return;
                    }

                    try {
                        console.log('üî® ANDROID DEBUG: Creating THREE.Points with:', {
                            geometry: geometry.type,
                            material: material.type,
                            position: props.position,
                            vertexCount: geometry.attributes?.position?.count || 0
                        });

                        const points = new window.THREE.Points(geometry, material);

                        // Apply properties BEFORE adding to scene
                        if (props.position) {
                            points.position.set(...props.position);
                            console.log('üìç ANDROID DEBUG: Set points position:', points.position);
                        }
                        if (props.rotation) {
                            points.rotation.set(...props.rotation);
                        }
                        if (props.scale) {
                            if (Array.isArray(props.scale)) {
                                points.scale.set(...props.scale);
                            } else {
                                points.scale.setScalar(props.scale);
                            }
                        }

                        // Set BOTH refs BEFORE adding to scene
                        pointsRef.current = points;
                        if (props.ref) {
                            props.ref.current = points;
                            console.log('‚úÖ ANDROID DEBUG: Set props.ref.current to points');
                        }

                        // Add to scene
                        window.currentScene.add(points);
                        pointsCreatedRef.current = true;

                        console.log('‚úÖ ANDROID DEBUG: points added to scene with ID:', points.uuid);
                        console.log('üîç ANDROID DEBUG: Total scene children:', window.currentScene.children.length);
                    } catch (error) {
                        console.error('‚ùå ANDROID DEBUG: Error creating points:', error);
                    }
                }, [props.geometry, props.position, props.rotation, props.scale, props.ref]);

                // Context value for children to register their geometry/material
                const contextValue = window.React.useMemo(() => ({
                    registerGeometry: (geo) => {
                        console.log('üìê ANDROID DEBUG: Geometry registered with points', geo.type);
                        geometryRef.current = geo;
                        // Use setTimeout to ensure we're not in the middle of a render
                        setTimeout(() => tryCreatePoints(), 0);
                    },
                    registerMaterial: (mat) => {
                        console.log('üé® ANDROID DEBUG: Material registered with points', mat.type);
                        materialRef.current = mat;
                        // Use setTimeout to ensure we're not in the middle of a render
                        setTimeout(() => tryCreatePoints(), 0);
                    }
                }), [tryCreatePoints]);

                // Cleanup on unmount
                window.React.useEffect(() => {
                    return () => {
                        if (pointsRef.current && window.currentScene) {
                            window.currentScene.remove(pointsRef.current);
                            if (pointsRef.current.geometry) pointsRef.current.geometry.dispose();
                            if (pointsRef.current.material) {
                                if (Array.isArray(pointsRef.current.material)) {
                                    pointsRef.current.material.forEach(m => m.dispose());
                                } else {
                                    pointsRef.current.material.dispose();
                                }
                            }
                            console.log('üóëÔ∏è ANDROID DEBUG: points cleaned up');
                        }
                    };
                }, []);

                // Render children within context so they can register themselves
                // Also provide ParentContext so non-geometry/material children can be added to this points
                return window.React.createElement(
                    ParentContext.Provider,
                    { value: pointsRef },
                    window.React.createElement(
                        PointsContext.Provider,
                        { value: contextValue },
                        props.children
                    )
                );
            };

            // 3D Object Primitives (non-mesh, non-line, non-points)
            window.ReactThreeFiber.group = createPrimitive('group', window.THREE.Group);
            window.ReactThreeFiber.lineSegments = createPrimitive('lineSegments', window.THREE.LineSegments);
            window.ReactThreeFiber.instancedMesh = createPrimitive('instancedMesh', window.THREE.InstancedMesh);

            // Geometry Components
            window.ReactThreeFiber.sphereGeometry = createPrimitive('sphereGeometry', window.THREE.SphereGeometry, true);
            window.ReactThreeFiber.boxGeometry = createPrimitive('boxGeometry', window.THREE.BoxGeometry, true);
            window.ReactThreeFiber.planeGeometry = createPrimitive('planeGeometry', window.THREE.PlaneGeometry, true);
            window.ReactThreeFiber.cylinderGeometry = createPrimitive('cylinderGeometry', window.THREE.CylinderGeometry, true);
            window.ReactThreeFiber.coneGeometry = createPrimitive('coneGeometry', window.THREE.ConeGeometry, true);
            window.ReactThreeFiber.torusGeometry = createPrimitive('torusGeometry', window.THREE.TorusGeometry, true);
            window.ReactThreeFiber.ringGeometry = createPrimitive('ringGeometry', window.THREE.RingGeometry, true);
            window.ReactThreeFiber.icosahedronGeometry = createPrimitive('icosahedronGeometry', window.THREE.IcosahedronGeometry, true);
            window.ReactThreeFiber.octahedronGeometry = createPrimitive('octahedronGeometry', window.THREE.OctahedronGeometry, true);
            window.ReactThreeFiber.dodecahedronGeometry = createPrimitive('dodecahedronGeometry', window.THREE.DodecahedronGeometry, true);
            window.ReactThreeFiber.tetrahedronGeometry = createPrimitive('tetrahedronGeometry', window.THREE.TetrahedronGeometry, true);
            window.ReactThreeFiber.bufferGeometry = createPrimitive('bufferGeometry', window.THREE.BufferGeometry, true);

            // Special: bufferAttribute component for attaching attributes to geometries
            window.ReactThreeFiber.bufferAttribute = function(props) {
                const parentGeometryRef = window.React.useRef(null);

                window.React.useEffect(() => {
                    console.log('üî¢ ANDROID DEBUG: bufferAttribute component mounting', {
                        attach: props.attach,
                        count: props.count,
                        itemSize: props.itemSize
                    });

                    // Find parent geometry by walking up the DOM tree
                    // In a real implementation, this would use React context
                    // For now, we'll access the most recently created geometry from the scene
                    const findGeometry = () => {
                        if (!window.currentScene) return null;

                        // Find the most recently added BufferGeometry or Points/LineSegments object
                        for (let i = window.currentScene.children.length - 1; i >= 0; i--) {
                            const child = window.currentScene.children[i];

                            // Check if it's a Points or LineSegments with geometry
                            if (child.geometry && child.geometry.isBufferGeometry) {
                                return child.geometry;
                            }

                            // Check if it has children with geometry
                            if (child.children) {
                                for (let j = child.children.length - 1; j >= 0; j--) {
                                    const grandChild = child.children[j];
                                    if (grandChild.geometry && grandChild.geometry.isBufferGeometry) {
                                        return grandChild.geometry;
                                    }
                                }
                            }
                        }
                        return null;
                    };

                    const geometry = findGeometry();
                    if (!geometry) {
                        console.warn('‚ö†Ô∏è ANDROID DEBUG: bufferAttribute could not find parent geometry');
                        return;
                    }

                    try {
                        // Create BufferAttribute
                        const attribute = new window.THREE.BufferAttribute(
                            props.array,
                            props.itemSize,
                            props.normalized || false
                        );

                        // Parse attach prop to get attribute name
                        // Format: "attributes-position" -> setAttribute('position', attribute)
                        let attributeName = 'position';
                        if (props.attach) {
                            const match = props.attach.match(/attributes?-(.+)/);
                            if (match) {
                                attributeName = match[1];
                            }
                        }

                        // Attach to geometry
                        geometry.setAttribute(attributeName, attribute);
                        parentGeometryRef.current = geometry;

                        console.log(`‚úÖ ANDROID DEBUG: bufferAttribute attached to geometry as "${attributeName}"`, {
                            count: props.count,
                            itemSize: props.itemSize
                        });

                        return () => {
                            if (parentGeometryRef.current) {
                                parentGeometryRef.current.deleteAttribute(attributeName);
                                console.log(`üóëÔ∏è ANDROID DEBUG: bufferAttribute "${attributeName}" removed`);
                            }
                        };
                    } catch (error) {
                        console.error('‚ùå ANDROID DEBUG: Error creating bufferAttribute:', error);
                    }
                }, [props.attach, props.array, props.itemSize, props.count, props.normalized]);

                return null; // This component doesn't render anything
            };

            // Material Components
            window.ReactThreeFiber.meshBasicMaterial = createPrimitive('meshBasicMaterial', window.THREE.MeshBasicMaterial, false, true);
            window.ReactThreeFiber.meshStandardMaterial = createPrimitive('meshStandardMaterial', window.THREE.MeshStandardMaterial, false, true);
            window.ReactThreeFiber.meshPhongMaterial = createPrimitive('meshPhongMaterial', window.THREE.MeshPhongMaterial, false, true);
            window.ReactThreeFiber.meshLambertMaterial = createPrimitive('meshLambertMaterial', window.THREE.MeshLambertMaterial, false, true);
            window.ReactThreeFiber.meshPhysicalMaterial = createPrimitive('meshPhysicalMaterial', window.THREE.MeshPhysicalMaterial, false, true);
            window.ReactThreeFiber.meshToonMaterial = createPrimitive('meshToonMaterial', window.THREE.MeshToonMaterial, false, true);
            window.ReactThreeFiber.meshNormalMaterial = createPrimitive('meshNormalMaterial', window.THREE.MeshNormalMaterial, false, true);
            window.ReactThreeFiber.meshDepthMaterial = createPrimitive('meshDepthMaterial', window.THREE.MeshDepthMaterial, false, true);
            window.ReactThreeFiber.pointsMaterial = createPrimitive('pointsMaterial', window.THREE.PointsMaterial, false, true);
            window.ReactThreeFiber.lineBasicMaterial = createPrimitive('lineBasicMaterial', window.THREE.LineBasicMaterial, false, true);
            window.ReactThreeFiber.lineDashedMaterial = createPrimitive('lineDashedMaterial', window.THREE.LineDashedMaterial, false, true);
            window.ReactThreeFiber.shaderMaterial = createPrimitive('shaderMaterial', window.THREE.ShaderMaterial, false, true);
            window.ReactThreeFiber.rawShaderMaterial = createPrimitive('rawShaderMaterial', window.THREE.RawShaderMaterial, false, true);

            // Light Components
            window.ReactThreeFiber.ambientLight = createPrimitive('ambientLight', window.THREE.AmbientLight, false, false, true);
            window.ReactThreeFiber.pointLight = createPrimitive('pointLight', window.THREE.PointLight, false, false, true);
            window.ReactThreeFiber.directionalLight = createPrimitive('directionalLight', window.THREE.DirectionalLight, false, false, true);
            window.ReactThreeFiber.spotLight = createPrimitive('spotLight', window.THREE.SpotLight, false, false, true);
            window.ReactThreeFiber.hemisphereLight = createPrimitive('hemisphereLight', window.THREE.HemisphereLight, false, false, true);

            // Helper Components
            window.ReactThreeFiber.gridHelper = createPrimitive('gridHelper', window.THREE.GridHelper);
            window.ReactThreeFiber.axesHelper = createPrimitive('axesHelper', window.THREE.AxesHelper);
            window.ReactThreeFiber.arrowHelper = createPrimitive('arrowHelper', window.THREE.ArrowHelper);
            window.ReactThreeFiber.boxHelper = createPrimitive('boxHelper', window.THREE.BoxHelper);
            window.ReactThreeFiber.cameraHelper = createPrimitive('cameraHelper', window.THREE.CameraHelper);

            // Special: color component for scene background
            window.ReactThreeFiber.color = function(props) {
                window.React.useEffect(() => {
                    if (window.currentScene && props.attach === 'background') {
                        const color = new window.THREE.Color(props.args?.[0] || props.color || 0x000000);
                        window.currentScene.background = color;
                        console.log('‚úÖ ANDROID DEBUG: Scene background color set', color);
                    }
                }, [props]);

                return null;
            };

            // ========================================
            // EXPOSE PRIMITIVES GLOBALLY
            // ========================================
            // Expose all primitive components directly to window so they can be used in JSX
            console.log('üîß ANDROID DEBUG: Exposing R3F primitives to window...');

            // Expose all components from ReactThreeFiber to window
            Object.keys(window.ReactThreeFiber).forEach(key => {
                if (key !== 'Canvas' && key !== 'useFrame' && key !== 'useThree' && key !== 'useLoader') {
                    window[key] = window.ReactThreeFiber[key];
                }
            });

            console.log('‚úÖ ANDROID DEBUG: React Three Fiber globals created synchronously');
            console.log('‚úÖ ANDROID DEBUG: R3F primitives added:', Object.keys(window.ReactThreeFiber).length, 'components');
            console.log('‚úÖ ANDROID DEBUG: Primitives exposed globally:', Object.keys(window.ReactThreeFiber).filter(k => !['Canvas', 'useFrame', 'useThree', 'useLoader'].includes(k)).length);

            // Verify each component was created successfully
            console.log('üîç ANDROID DEBUG: Verifying R3F components:', {
                Canvas: typeof window.ReactThreeFiber.Canvas,
                useFrame: typeof window.ReactThreeFiber.useFrame,
                useThree: typeof window.ReactThreeFiber.useThree,
                useLoader: typeof window.ReactThreeFiber.useLoader
            });
            
            return true;
            
            } catch (error) {
                console.error('‚ùå ANDROID DEBUG: Error creating ReactThreeFiber globals:', error);
                return false;
            }
        }
        
        // DEPRECATED: Old async version without reconciler - DO NOT USE
        // Use createReactThreeFiberGlobalsSync() instead which has reconciler integration
        async function createReactThreeFiberGlobals_DEPRECATED() {
            console.log('‚ö†Ô∏è ANDROID DEBUG: DEPRECATED async Canvas version called (no reconciler)!');
            
            if (!window.React || !window.THREE) {
                console.error('‚ùå ANDROID DEBUG: React or THREE not available for R3F creation');
                return false;
            }
            
            // DEPRECATED: This Canvas lacks reconciler - kept for fallback only
            window.ReactThreeFiber_FALLBACK = {
                Canvas: function(props) {
                    props = props || {}; // Handle undefined props

                    const canvasRef = window.React.useRef();
                    const sceneRef = window.React.useRef();
                    const rendererRef = window.React.useRef();
                    
                    window.React.useEffect(() => {
                        if (!canvasRef.current) return;
                        
                        // Create Three.js scene
                        const scene = new window.THREE.Scene();
                        const camera = new window.THREE.PerspectiveCamera(
                            props.camera?.fov || 75,
                            canvasRef.current.clientWidth / canvasRef.current.clientHeight,
                            0.1,
                            1000
                        );
                        
                        if (props.camera?.position) {
                            camera.position.set(...props.camera.position);
                        } else {
                            camera.position.set(0, 0, 5);
                        }
                        
                        const renderer = new window.THREE.WebGLRenderer({ 
                            canvas: canvasRef.current,
                            antialias: props.gl?.antialias || true
                        });
                        renderer.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);
                        renderer.setClearColor(0x000000, 1);
                        
                        sceneRef.current = scene;
                        rendererRef.current = renderer;
                        
                        // Store references globally for child components
                        window.currentScene = scene;
                        window.currentCamera = camera; 
                        window.currentRenderer = renderer;
                        
                        // Render loop with frame callbacks
                        function animate() {
                            requestAnimationFrame(animate);

                            // Call all registered useFrame callbacks
                            if (window.currentScene && window.currentCamera && window.currentRenderer && window.currentClock) {
                                const state = {
                                    scene: window.currentScene,
                                    camera: window.currentCamera,
                                    renderer: window.currentRenderer,
                                    clock: window.currentClock,
                                    gl: window.currentRenderer
                                };
                                const delta = window.currentClock.getDelta();

                                window.R3FFrameCallbacks.forEach(callback => {
                                    try {
                                        callback(state, delta);
                                    } catch (error) {
                                        console.error('‚ùå ANDROID DEBUG: useFrame callback error:', error);
                                    }
                                });
                            }

                            // Render the scene
                            if (window.currentScene && window.currentCamera && window.currentRenderer) {
                                window.currentRenderer.render(window.currentScene, window.currentCamera);
                            }
                        }
                        animate();
                        
                        // Cleanup
                        return () => {
                            renderer.dispose();
                        };
                    }, []);
                    
                    return window.React.createElement('canvas', {
                        ref: canvasRef,
                        style: { width: '100%', height: '100%', display: 'block', ...props.style }
                    });
                },
                
                useFrame: function(callback) {
                    // Register callback globally for animation loop to call
                    // This works with reconciler approach where components are called outside React
                    window.R3FFrameCallbacks.push(callback);
                },
                
                useThree: function() {
                    return {
                        scene: window.currentScene,
                        camera: window.currentCamera,
                        renderer: window.currentRenderer
                    };
                }
            };
            
            console.log('‚úÖ ANDROID DEBUG: React Three Fiber globals created');
            return true;
        }
        
        // Create Drei globals synchronously
        function createDreiGlobalsSync() {
            console.log('üîß ANDROID DEBUG: Creating Drei globals synchronously...');
            
            if (!window.THREE) {
                console.error('‚ùå ANDROID DEBUG: THREE not available for Drei creation');
                console.error('   THREE:', typeof window.THREE);
                return false;
            }
            
            try {
            
            window.Drei = {
                OrbitControls: function(props) {
                    window.React.useEffect(() => {
                        console.log('üéÆ ANDROID DEBUG: Setting up OrbitControls...');
                        
                        if (!window.currentCamera || !window.currentRenderer) {
                            console.log('‚è≥ ANDROID DEBUG: Waiting for camera/renderer...');
                            return;
                        }
                        
                        // Simple orbit controls implementation
                        let isMouseDown = false;
                        let mouseX = 0, mouseY = 0;
                        let targetRotationX = 0, targetRotationY = 0;
                        let rotationX = 0, rotationY = 0;
                        
                        function onMouseDown(event) {
                            isMouseDown = true;
                            mouseX = event.clientX;
                            mouseY = event.clientY;
                        }
                        
                        function onMouseMove(event) {
                            if (!isMouseDown) return;
                            
                            const deltaX = event.clientX - mouseX;
                            const deltaY = event.clientY - mouseY;
                            
                            targetRotationY += deltaX * 0.01;
                            targetRotationX += deltaY * 0.01;
                            
                            mouseX = event.clientX;
                            mouseY = event.clientY;
                        }
                        
                        function onMouseUp() {
                            isMouseDown = false;
                        }
                        
                        function animate() {
                            rotationX += (targetRotationX - rotationX) * 0.1;
                            rotationY += (targetRotationY - rotationY) * 0.1;
                            
                            if (window.currentCamera) {
                                const radius = 5;
                                window.currentCamera.position.x = Math.sin(rotationY) * radius;
                                window.currentCamera.position.z = Math.cos(rotationY) * radius;
                                window.currentCamera.position.y = Math.sin(rotationX) * radius;
                                window.currentCamera.lookAt(0, 0, 0);
                            }
                            
                            requestAnimationFrame(animate);
                        }
                        
                        const canvas = window.currentRenderer?.domElement;
                        if (canvas) {
                            canvas.addEventListener('mousedown', onMouseDown);
                            canvas.addEventListener('mousemove', onMouseMove);
                            canvas.addEventListener('mouseup', onMouseUp);
                            animate();
                            
                            console.log('‚úÖ ANDROID DEBUG: OrbitControls set up successfully');
                            
                            return () => {
                                canvas.removeEventListener('mousedown', onMouseDown);
                                canvas.removeEventListener('mousemove', onMouseMove);
                                canvas.removeEventListener('mouseup', onMouseUp);
                            };
                        }
                    }, []);
                    
                    return null; // OrbitControls doesn't render anything
                },
                
                Box: function(props) {
                    window.React.useEffect(() => {
                        console.log('üì¶ ANDROID DEBUG: Creating Box component...');
                        if (window.currentScene) {
                            const geometry = new window.THREE.BoxGeometry(
                                props.args?.[0] || 1, 
                                props.args?.[1] || 1, 
                                props.args?.[2] || 1
                            );
                            const material = new window.THREE.MeshStandardMaterial({ 
                                color: props.color || 0x00ff00 
                            });
                            const mesh = new window.THREE.Mesh(geometry, material);
                            
                            if (props.position) {
                                mesh.position.set(...props.position);
                            }
                            if (props.rotation) {
                                mesh.rotation.set(...props.rotation);
                            }
                            
                            window.currentScene.add(mesh);
                            console.log('‚úÖ ANDROID DEBUG: Box added to scene');
                            
                            return () => {
                                window.currentScene.remove(mesh);
                                geometry.dispose();
                                material.dispose();
                            };
                        }
                    }, [props]);
                    
                    return null;
                },
                
                Sphere: function(props) {
                    window.React.useEffect(() => {
                        console.log('‚ö™ ANDROID DEBUG: Creating Sphere component...');
                        if (window.currentScene) {
                            const geometry = new window.THREE.SphereGeometry(
                                props.args?.[0] || 1,
                                props.args?.[1] || 32,
                                props.args?.[2] || 32
                            );
                            const material = new window.THREE.MeshStandardMaterial({ 
                                color: props.color || 0xff0000 
                            });
                            const mesh = new window.THREE.Mesh(geometry, material);
                            
                            if (props.position) {
                                mesh.position.set(...props.position);
                            }
                            if (props.rotation) {
                                mesh.rotation.set(...props.rotation);
                            }
                            
                            window.currentScene.add(mesh);
                            console.log('‚úÖ ANDROID DEBUG: Sphere added to scene');
                            
                            return () => {
                                window.currentScene.remove(mesh);
                                geometry.dispose();
                                material.dispose();
                            };
                        }
                    }, [props]);
                    
                    return null;
                },
                
                Environment: function(props) {
                    window.React.useEffect(() => {
                        console.log('üåç ANDROID DEBUG: Setting up Environment...');
                        if (window.currentScene) {
                            // Add basic environment lighting
                            const ambientLight = new window.THREE.AmbientLight(0x404040, 0.4);
                            const directionalLight = new window.THREE.DirectionalLight(0xffffff, 1);
                            directionalLight.position.set(5, 5, 5);

                            window.currentScene.add(ambientLight);
                            window.currentScene.add(directionalLight);
                            console.log('‚úÖ ANDROID DEBUG: Environment lighting added');

                            // Optional: Add a basic skybox background
                            if (props.background) {
                                window.currentScene.background = new window.THREE.Color(props.background);
                            }

                            return () => {
                                window.currentScene.remove(ambientLight);
                                window.currentScene.remove(directionalLight);
                            };
                        }
                    }, [props]);

                    return null;
                },

                Trail: function(props) {
                    console.log('‚ú® ANDROID DEBUG: Trail component rendered (pass-through)');
                    // Trail is a complex component that creates trailing effects
                    // For now, we'll render a simple pass-through that renders its children
                    // This prevents errors when Trail is used in user code
                    return props.children || null;
                },

                Stars: function(props) {
                    window.React.useEffect(() => {
                        console.log('‚≠ê ANDROID DEBUG: Creating Stars component...');
                        if (window.currentScene) {
                            const radius = props.radius || 100;
                            const depth = props.depth || 50;
                            const count = props.count || 5000;
                            const factor = props.factor || 4;

                            // Create geometry with random positions
                            const geometry = new window.THREE.BufferGeometry();
                            const positions = new Float32Array(count * 3);

                            for (let i = 0; i < count; i++) {
                                const i3 = i * 3;

                                // Generate random positions in a sphere
                                const r = radius * Math.random();
                                const theta = Math.random() * Math.PI * 2;
                                const phi = Math.acos(2 * Math.random() - 1);

                                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                                positions[i3 + 2] = (r * Math.cos(phi)) - depth;
                            }

                            geometry.setAttribute('position', new window.THREE.BufferAttribute(positions, 3));

                            // CRITICAL FIX: Reduced star size from 0.5*factor to 0.05*factor
                            // Mobile WebGL renders large point sizes as blocky squares, not dots
                            // With factor=4, this gives size=0.2 instead of 2.0 (10x smaller)
                            const material = new window.THREE.PointsMaterial({
                                color: 0xffffff,
                                size: 0.05 * factor,  // FIXED: Was 0.5, now 0.05 for tiny dot-like stars
                                sizeAttenuation: true,
                                transparent: true,
                                opacity: 0.8
                            });

                            console.log(`‚≠ê ANDROID DEBUG: Stars material configured - size: ${0.05 * factor}, count: ${count}, radius: ${radius}`);

                            // Create points mesh
                            const stars = new window.THREE.Points(geometry, material);

                            window.currentScene.add(stars);
                            console.log(`‚úÖ ANDROID DEBUG: Stars added to scene (${count} stars, radius: ${radius})`);

                            return () => {
                                window.currentScene.remove(stars);
                                geometry.dispose();
                                material.dispose();
                            };
                        }
                    }, [props]);

                    return null;
                },

                PerspectiveCamera: function(props) {
                    console.log('üì∑ ANDROID DEBUG: PerspectiveCamera component rendered (using default camera)');
                    // This is a stub - the Canvas component already creates a PerspectiveCamera
                    // In real R3F, this would replace the default camera, but for simplicity we'll just ignore it
                    return null;
                },

                Text: function(props) {
                    const meshRef = window.React.useRef(null);

                    window.React.useEffect(() => {
                        console.log('üìù ANDROID DEBUG: Creating Text component with text:', props.children);
                        if (window.currentScene) {
                            // Create a simple text mesh using THREE.js
                            // For basic text support without loading fonts, we'll create a plane with text rendered on canvas
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');

                            // Set canvas size
                            canvas.width = 512;
                            canvas.height = 256;

                            // Set font and text properties
                            const fontSize = props.fontSize || 1;
                            const actualFontSize = fontSize * 100; // Scale up for canvas
                            context.font = `bold ${actualFontSize}px Arial`;
                            context.fillStyle = props.color || 'white';
                            context.textAlign = props.anchorX || 'center';
                            context.textBaseline = 'middle';

                            // Clear canvas and draw text
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            const text = props.children || '';
                            context.fillText(text, canvas.width / 2, canvas.height / 2);

                            // Create texture from canvas
                            const texture = new window.THREE.CanvasTexture(canvas);
                            texture.needsUpdate = true;

                            // Create material with texture
                            const material = new window.THREE.MeshBasicMaterial({
                                map: texture,
                                transparent: true,
                                side: window.THREE.DoubleSide,
                                depthWrite: false
                            });

                            // Create plane geometry - estimate width based on text length
                            const textLength = (text || '').length;
                            const width = (props.fontSize || 1) * textLength * 0.6;
                            const height = (props.fontSize || 1);
                            const geometry = new window.THREE.PlaneGeometry(width, height);

                            // Create mesh
                            const mesh = new window.THREE.Mesh(geometry, material);

                            // Apply position
                            if (props.position) {
                                mesh.position.set(...props.position);
                            }

                            // Make text billboard (always face camera) if not specified otherwise
                            if (window.currentCamera && !props.rotation) {
                                mesh.lookAt(window.currentCamera.position);
                            }

                            window.currentScene.add(mesh);
                            meshRef.current = mesh;
                            console.log('‚úÖ ANDROID DEBUG: Text added to scene');

                            return () => {
                                if (meshRef.current && window.currentScene) {
                                    window.currentScene.remove(meshRef.current);
                                    geometry.dispose();
                                    material.dispose();
                                    texture.dispose();
                                }
                            };
                        }
                    }, [props.children, props.position, props.fontSize, props.color, props.anchorX]);

                    return null;
                }
            };


            // Immediately verify all components are available
            console.log('üîç ANDROID DEBUG: Verifying Drei components immediately after creation:', {
                OrbitControls: typeof window.Drei.OrbitControls,
                Box: typeof window.Drei.Box,
                Sphere: typeof window.Drei.Sphere,
                Environment: typeof window.Drei.Environment
            });
            
            console.log('‚úÖ ANDROID DEBUG: Drei globals created synchronously');
            
            // Verify each component was created successfully
            console.log('üîç ANDROID DEBUG: Verifying Drei components:', {
                OrbitControls: typeof window.Drei.OrbitControls,
                Box: typeof window.Drei.Box,
                Sphere: typeof window.Drei.Sphere,
                Environment: typeof window.Drei.Environment
            });
            
            return true;
            
            } catch (error) {
                console.error('‚ùå ANDROID DEBUG: Error creating Drei globals:', error);
                return false;
            }
        }
        
        // Create Drei globals with essential controls
        async function createDreiGlobals() {
            console.log('üîß ANDROID DEBUG: Creating Drei globals...');
            
            if (!window.THREE) {
                console.error('‚ùå ANDROID DEBUG: THREE not available for Drei creation');
                return false;
            }
            
            window.Drei = {
                OrbitControls: function(props) {
                    window.React.useEffect(() => {
                        if (!window.currentCamera || !window.currentRenderer) return;
                        
                        // Simple orbit controls implementation
                        let isMouseDown = false;
                        let mouseX = 0, mouseY = 0;
                        let targetRotationX = 0, targetRotationY = 0;
                        let rotationX = 0, rotationY = 0;
                        
                        function onMouseDown(event) {
                            isMouseDown = true;
                            mouseX = event.clientX;
                            mouseY = event.clientY;
                        }
                        
                        function onMouseMove(event) {
                            if (!isMouseDown) return;
                            
                            const deltaX = event.clientX - mouseX;
                            const deltaY = event.clientY - mouseY;
                            
                            targetRotationY += deltaX * 0.01;
                            targetRotationX += deltaY * 0.01;
                            
                            mouseX = event.clientX;
                            mouseY = event.clientY;
                        }
                        
                        function onMouseUp() {
                            isMouseDown = false;
                        }
                        
                        function animate() {
                            rotationX += (targetRotationX - rotationX) * 0.1;
                            rotationY += (targetRotationY - rotationY) * 0.1;
                            
                            if (window.currentCamera) {
                                const radius = 5;
                                window.currentCamera.position.x = Math.sin(rotationY) * radius;
                                window.currentCamera.position.z = Math.cos(rotationY) * radius;
                                window.currentCamera.position.y = Math.sin(rotationX) * radius;
                                window.currentCamera.lookAt(0, 0, 0);
                            }
                            
                            requestAnimationFrame(animate);
                        }
                        
                        const canvas = window.currentRenderer?.domElement;
                        if (canvas) {
                            canvas.addEventListener('mousedown', onMouseDown);
                            canvas.addEventListener('mousemove', onMouseMove);
                            canvas.addEventListener('mouseup', onMouseUp);
                            animate();
                            
                            return () => {
                                canvas.removeEventListener('mousedown', onMouseDown);
                                canvas.removeEventListener('mousemove', onMouseMove);
                                canvas.removeEventListener('mouseup', onMouseUp);
                            };
                        }
                    }, []);

                    return null; // OrbitControls doesn't render anything
                },

                Box: function(props) {
                    return null; // Simple stub
                },

                Sphere: function(props) {
                    return null; // Simple stub
                },

                Environment: function(props) {
                    return null; // Simple stub
                },

                Trail: function(props) {
                    console.log('‚ú® ANDROID DEBUG: Trail component rendered (pass-through)');
                    return props.children || null;
                },

                Stars: function(props) {
                    window.React.useEffect(() => {
                        console.log('‚≠ê ANDROID DEBUG: Creating Stars component...');
                        if (window.currentScene) {
                            const radius = props.radius || 100;
                            const depth = props.depth || 50;
                            const count = props.count || 5000;
                            const factor = props.factor || 4;

                            // Create geometry with random positions
                            const geometry = new window.THREE.BufferGeometry();
                            const positions = new Float32Array(count * 3);

                            for (let i = 0; i < count; i++) {
                                const i3 = i * 3;

                                // Generate random positions in a sphere
                                const r = radius * Math.random();
                                const theta = Math.random() * Math.PI * 2;
                                const phi = Math.acos(2 * Math.random() - 1);

                                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                                positions[i3 + 2] = (r * Math.cos(phi)) - depth;
                            }

                            geometry.setAttribute('position', new window.THREE.BufferAttribute(positions, 3));

                            // Create material
                            const material = new window.THREE.PointsMaterial({
                                color: 0xffffff,
                                size: 0.5 * factor,
                                sizeAttenuation: true,
                                transparent: true,
                                opacity: 0.8
                            });

                            // Create points mesh
                            const stars = new window.THREE.Points(geometry, material);

                            window.currentScene.add(stars);
                            console.log(`‚úÖ ANDROID DEBUG: Stars added to scene (${count} stars, radius: ${radius})`);

                            return () => {
                                window.currentScene.remove(stars);
                                geometry.dispose();
                                material.dispose();
                            };
                        }
                    }, [props]);

                    return null;
                }
            };

            console.log('‚úÖ ANDROID DEBUG: Drei globals created');
            return true;
        }
        
        // Add immediate simple library loading as backup
        function loadLibrariesSimple() {
            console.log('üîÑ ANDROID DEBUG: Loading libraries with simple approach...');
            
            // Load React directly
            const reactScript = document.createElement('script');
            reactScript.src = 'https://unpkg.com/react@18/umd/react.production.min.js';
            reactScript.onload = () => {
                console.log('‚úÖ ANDROID DEBUG: React loaded directly');
                
                // Load ReactDOM
                const reactDOMScript = document.createElement('script');
                reactDOMScript.src = 'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js';
                reactDOMScript.onload = () => {
                    console.log('‚úÖ ANDROID DEBUG: ReactDOM loaded directly');
                    
                    // Load Three.js
                    const threeScript = document.createElement('script');
                    threeScript.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
                    threeScript.onload = () => {
                        console.log('‚úÖ ANDROID DEBUG: Three.js loaded directly');
                        
                        // Create React Three Fiber and Drei globals
                        setTimeout(() => {
                            createReactThreeFiberGlobalsSync();  // Use sync version with reconciler
                            createDreiGlobalsSync();
                            
                            console.log('üìö ANDROID DEBUG: Simple loading complete - final status:', {
                                React: typeof window.React,
                                ReactDOM: typeof window.ReactDOM,
                                THREE: typeof window.THREE,
                                ReactThreeFiber: typeof window.ReactThreeFiber,
                                Drei: typeof window.Drei
                            });
                        }, 500);
                    };
                    threeScript.onerror = () => console.error('‚ùå Three.js failed');
                    document.head.appendChild(threeScript);
                };
                reactDOMScript.onerror = () => console.error('‚ùå ReactDOM failed');
                document.head.appendChild(reactDOMScript);
            };
            reactScript.onerror = () => console.error('‚ùå React failed');
            document.head.appendChild(reactScript);
        }
        
        // Start both loading approaches
        console.log('üöÄ ANDROID DEBUG: Starting library loading...');
        loadAllLibraries().catch(error => {
            console.error('‚ùå ANDROID DEBUG: Advanced loading failed:', error);
            console.log('üîÑ ANDROID DEBUG: Falling back to simple loading...');
            loadLibrariesSimple();
        });
        
        // Also start simple loading as immediate backup
        setTimeout(() => {
            if (!window.React || !window.ReactDOM || !window.THREE) {
                console.log('‚è∞ ANDROID DEBUG: Libraries not loaded after 2s, trying simple approach...');
                loadLibrariesSimple();
            }
        }, 2000);
    </script>
    
    <!-- Initialize React Three Fiber globals -->
    <script>
        // Redirect console output to Xcode debug window via WebKit messages
        // Store original console methods BEFORE any overrides
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        
        function debugLog(level, ...args) {
            const message = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            
            try {
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                    window.webkit.messageHandlers.playgroundHandler.postMessage({
                        action: 'consoleLog',
                        data: { level: level, message: message }
                    });
                }
            } catch (error) {
                // Fallback to original console - no recursion
                if (level === 'error') {
                    originalError.call(console, 'debugLog error:', error);
                }
            }
            
            // Also log to original console methods - no recursion
            if (level === 'error') {
                originalError.call(console, ...args);
            } else if (level === 'warn') {
                originalWarn.call(console, ...args);
            } else {
                originalLog.call(console, ...args);
            }
        }
        
        // Override console methods to redirect to Xcode
        console.log = function(...args) {
            debugLog('log', ...args);
        };
        
        console.warn = function(...args) {
            debugLog('warn', ...args);
        };
        
        console.error = function(...args) {
            debugLog('error', ...args);
        };
        
        // Enhanced global setup function called after libraries load
        function setupLibraryGlobals() {
            console.log('üöÄ ANDROID DEBUG: Setting up library globals...');
            
            // Wait a bit for all libraries to fully initialize
            setTimeout(() => {
                try {
                    // Safety check - don't run if our custom components are already set up
                    if (window.Drei && window.Drei.Box && window.Drei.Sphere && window.Drei.Environment) {
                        console.log('‚úÖ ANDROID DEBUG: Custom components already exist, skipping global setup');
                        
                        // Just do the final component check and reporting
                        const dreiComponents = {
                            OrbitControls: !!window.Drei.OrbitControls,
                            Box: !!window.Drei.Box,
                            Sphere: !!window.Drei.Sphere,
                            Environment: !!window.Drei.Environment
                        };
                        console.log('üîç ANDROID DEBUG: Drei components:', dreiComponents);
                        
                        return;
                    }
                    
                    console.log('üîß ANDROID DEBUG: Custom components not complete, proceeding with setup...');
                    // Log all available globals to understand what's actually loaded
                    const allGlobals = {};
                    for (const key in window) {
                        if (key.toLowerCase().includes('react') || key.toLowerCase().includes('three') || key.toLowerCase().includes('drei') || key === 'THREE' || key === 'Canvas') {
                            allGlobals[key] = typeof window[key];
                        }
                    }
                    console.log('üîç ANDROID DEBUG: All React/Three related globals:', allGlobals);
                    
                    // Set up React globals with fallbacks
                    if (!window.React) {
                        window.React = (typeof React !== 'undefined') ? React : null;
                    }
                    if (!window.ReactDOM) {
                        window.ReactDOM = (typeof ReactDOM !== 'undefined') ? ReactDOM : null;
                    }
                    if (!window.THREE) {
                        window.THREE = (typeof THREE !== 'undefined') ? THREE : null;
                    }
                    
                    // Set up React Three Fiber - check all possible locations
                    if (!window.ReactThreeFiber) {
                        // Check common R3F global names
                        const r3fCandidates = [
                            window.ReactThreeFiber,
                            window.R3F,
                            window.Fiber,
                            window['@react-three/fiber'],
                            window.Canvas && { Canvas: window.Canvas, useFrame: window.useFrame, useThree: window.useThree },
                            (typeof ReactThreeFiber !== 'undefined') ? ReactThreeFiber : null,
                            (typeof R3F !== 'undefined') ? R3F : null
                        ];
                        
                        for (const candidate of r3fCandidates) {
                            if (candidate && typeof candidate === 'object') {
                                console.log('‚úÖ ANDROID DEBUG: Found React Three Fiber candidate:', candidate);
                                window.ReactThreeFiber = candidate;
                                break;
                            }
                        }
                        
                        // If still not found, create from individual globals
                        if (!window.ReactThreeFiber && window.Canvas) {
                            console.log('üîß ANDROID DEBUG: Creating ReactThreeFiber from individual globals');
                            window.ReactThreeFiber = {
                                Canvas: window.Canvas,
                                useFrame: window.useFrame,
                                useThree: window.useThree,
                                useLoader: window.useLoader
                            };
                        }
                    }
                    
                    // Set up Drei - ensure our custom implementation is preserved and complete
                    if (!window.Drei || !window.Drei.Box || !window.Drei.Sphere || !window.Drei.Environment) {
                        console.log('üîß ANDROID DEBUG: Drei incomplete or missing, ensuring complete custom implementation...');
                        
                        // Force recreation of complete custom Drei implementation
                        createDreiGlobalsSync();
                        
                        console.log('‚úÖ ANDROID DEBUG: Custom Drei implementation created/updated');
                        console.log('   All components:', Object.keys(window.Drei || {}));
                    } else {
                        console.log('‚úÖ ANDROID DEBUG: Drei already complete, preserving existing implementation');
                        console.log('   Existing components:', Object.keys(window.Drei));
                    }
                    
                    // Final validation and status check
                    const finalStatus = {
                        React: validateLibraryLoaded('React'),
                        ReactDOM: validateLibraryLoaded('ReactDOM'),
                        THREE: validateLibraryLoaded('THREE'),
                        ReactThreeFiber: validateLibraryLoaded('ReactThreeFiber'),
                        Drei: validateLibraryLoaded('Drei')
                    };
                    
                    // Update the loading progress to reflect actual status
                    window.libraryLoadingProgress = finalStatus;
                    
                    console.log('üöÄ ANDROID DEBUG: Final libraries status after setup:', finalStatus);
                    
                    // Detailed component check
                    if (window.ReactThreeFiber) {
                        const r3fComponents = {
                            Canvas: !!window.ReactThreeFiber.Canvas,
                            useFrame: !!window.ReactThreeFiber.useFrame,
                            useThree: !!window.ReactThreeFiber.useThree,
                            useLoader: !!window.ReactThreeFiber.useLoader
                        };
                        console.log('üîç ANDROID DEBUG: React Three Fiber components:', r3fComponents);
                    }
                    
                    if (window.Drei) {
                        const dreiComponents = {
                            OrbitControls: !!window.Drei.OrbitControls,
                            Box: !!window.Drei.Box,
                            Sphere: !!window.Drei.Sphere,
                            Environment: !!window.Drei.Environment
                        };
                        console.log('üîç ANDROID DEBUG: Drei components:', dreiComponents);
                        
                        // üîß CRITICAL FIX: If any components are missing, recreate them now
                        const missingComponents = Object.entries(dreiComponents).filter(([_, exists]) => !exists).map(([name, _]) => name);
                        if (missingComponents.length > 0) {
                            console.warn('‚ö†Ô∏è ANDROID DEBUG: Missing Drei components detected:', missingComponents);
                            console.log('üîß ANDROID DEBUG: Force recreating complete Drei implementation...');
                            createDreiGlobalsSync();
                            
                            // Re-check after recreation
                            const recheck = {
                                OrbitControls: !!window.Drei.OrbitControls,
                                Box: !!window.Drei.Box,
                                Sphere: !!window.Drei.Sphere,
                                Environment: !!window.Drei.Environment
                            };
                            console.log('‚úÖ ANDROID DEBUG: Drei components after recreation:', recheck);
                        }
                    }
                    
                    // Send comprehensive library status update to native (iOS or Android)
                    try {
                        const statusMessage = {
                            action: 'libraryStatusUpdate',
                            data: {
                                libraries: finalStatus,
                                loadingProgress: window.libraryLoadingProgress,
                                components: {
                                    r3f: window.ReactThreeFiber ? Object.keys(window.ReactThreeFiber) : [],
                                    drei: window.Drei ? Object.keys(window.Drei) : []
                                },
                                timestamp: Date.now(),
                                loadingComplete: librariesReady,
                                setupComplete: true
                            }
                        };

                        // iOS WebKit message handler
                        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                            window.webkit.messageHandlers.playgroundHandler.postMessage(statusMessage);
                            console.log('üì° ANDROID DEBUG: Sent comprehensive library status update to iOS');
                        }
                        // Android JavaScript interface
                        else if (window.AndroidBridge && window.AndroidBridge.postMessage) {
                            window.AndroidBridge.postMessage(JSON.stringify(statusMessage));
                            console.log('üì° ANDROID DEBUG: Sent comprehensive library status update to Android');
                        }
                    
                    // üîß CRITICAL FIX: Auto-run test scene when all libraries are ready
                    if (finalStatus.React && finalStatus.ReactDOM && finalStatus.ReactThreeFiber && finalStatus.Drei) {
                        console.log('üöÄ ANDROID DEBUG: All libraries ready - auto-running test scene...');
                        setTimeout(() => {
                            testBasicSceneRendering();
                        }, 500);
                    }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è ANDROID DEBUG: Could not send library status to Swift:', error);
                    }
                    
                } catch (error) {
                    console.error('‚ùå ANDROID DEBUG: Error setting up library globals:', error);
                }
            }, 1000); // Give libraries more time to fully initialize (1 second)
        }

        // Expose setupLibraryGlobals to global scope
        window.setupLibraryGlobals = setupLibraryGlobals;
    </script>
    
    <!-- Monaco Editor -->
    <script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>
    
    <script>
        let editor = null;
        let buildService = null;
        let consoleElement = null;
        let currentBundle = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ ANDROID DEBUG: DOM Content Loaded - starting initialization');
            
            // IMMEDIATELY load default scene while Monaco loads
            loadDefaultScene();
            
            console.log('üéØ ANDROID DEBUG: Starting Monaco editor initialization...');
            initializeEditor();
            initializeBuildService();
            initializeConsole();
            setupEventListeners();
            hideLoadingOverlay();
            
            // Backup notification in case Monaco fails or takes too long
            setTimeout(() => {
                if (!editor) {
                    console.warn('‚ö†Ô∏è Monaco not loaded after 15 seconds, sending fallback notification');
                    notifySwiftInitialization({
                        editorReady: false,
                        engineReady: true,
                        framework: 'reactThreeFiber',
                        error: 'Monaco loading timeout'
                    });
                }
            }, 15000);
        });
        
        function initializeEditor() {
            console.log('üéØ ANDROID DEBUG: Monaco editor initialization starting...');
            
            // Check if editor container exists
            const editorContainer = document.getElementById('editor');
            if (!editorContainer) {
                console.error('‚ùå ANDROID DEBUG: Editor container not found!');
                return;
            }
            console.log('‚úÖ ANDROID DEBUG: Editor container found, size:', editorContainer.offsetWidth, 'x', editorContainer.offsetHeight);
            
            // Configure Monaco with fallback CDNs
            const monacoCDNs = [
                'https://unpkg.com/monaco-editor@0.44.0/min/vs',
                'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs'
            ];
            
            let cdnIndex = 0;
            
            function tryLoadMonaco() {
                const cdnPath = monacoCDNs[cdnIndex];
                // Trying Monaco CDN
                
                require.config({ 
                    paths: { vs: cdnPath },
                    timeout: 10000 // 10 second timeout
                });
                
                require(['vs/editor/editor.main'], function () {
                    initializeMonacoEditor();
                }, function(error) {
                    // Monaco CDN failed, trying next
                    cdnIndex++;
                    if (cdnIndex < monacoCDNs.length) {
                        tryLoadMonaco();
                    } else {
                        console.error('All Monaco CDNs failed');
                        // Still notify initialization but with editor disabled
                        notifySwiftInitialization({
                            editorReady: false,
                            engineReady: true,
                            framework: 'reactThreeFiber',
                            error: 'Monaco editor failed to load'
                        });
                    }
                });
            }
            
            tryLoadMonaco();
        }
        
        function initializeMonacoEditor() {
            try {
                console.log('üéØ ANDROID DEBUG: Monaco loaded successfully, creating editor...');
                console.log('üîç ANDROID DEBUG: Monaco object:', !!monaco, 'monaco.editor:', !!monaco.editor);
                
                console.log('üéØ ANDROID DEBUG: Configuring Monaco TypeScript settings...');
                monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
                    target: monaco.languages.typescript.ScriptTarget.ES2020,
                    allowNonTsExtensions: true,
                    moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
                    module: monaco.languages.typescript.ModuleKind.CommonJS,
                    noEmit: true,
                    esModuleInterop: true,
                    jsx: monaco.languages.typescript.JsxEmit.ReactJSX,
                    reactNamespace: 'React',
                    allowJs: true,
                    typeRoots: ['node_modules/@types']
                });
                
                console.log('üéØ ANDROID DEBUG: Creating Monaco editor instance...');
                const editorElement = document.getElementById('editor');
                console.log('üìè ANDROID DEBUG: Editor element:', !!editorElement, 'Size:', editorElement?.offsetWidth, 'x', editorElement?.offsetHeight);
                
                editor = monaco.editor.create(editorElement, {
                    value: getDefaultCode(),
                    language: 'typescript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    fontSize: 14,
                    minimap: { enabled: false },
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    formatOnPaste: true,
                    formatOnType: true
                });
                
                // Add keyboard shortcuts
                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyB, () => {
                    buildScene();
                });
                
                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
                    runScene();
                });
                
                console.log('‚úÖ ANDROID DEBUG: Monaco editor initialized successfully!');
                console.log('üìä ANDROID DEBUG: Editor info:', {
                    hasEditor: !!editor,
                    hasGetValue: !!(editor && editor.getValue),
                    hasSetValue: !!(editor && editor.setValue),
                    currentValue: editor ? editor.getValue().length + ' chars' : 'N/A'
                });
                
                // Make editor available globally for readiness checks
                window.editor = editor;
                window.monaco = monaco;
                window.editorReady = true; // Critical flag for readiness check
                
                // Notify Swift that Monaco is ready
                notifySwiftInitialization({
                    editorReady: true,
                    engineReady: true,
                    framework: 'reactThreeFiber'
                });
                
            } catch (error) {
                console.error('‚ùå Monaco editor initialization failed:', error);
                // Still notify but with error
                notifySwiftInitialization({
                    editorReady: false,
                    engineReady: true,
                    framework: 'reactThreeFiber',
                    error: error.message
                });
            }
        }
        
        function initializeBuildService() {
            // BuildService will be injected by the app
            console.log('‚è≥ Waiting for build service initialization...');
        }

        // ========================================
        // REAL R3F APPROACH (iOS version)
        // ========================================
        // We load the REAL React Three Fiber library from CDN (see loadRealR3F above)
        // Then use Babel to transform user's JSX code
        // The real R3F library handles all hooks, components, and rendering
        // No Sandpack bundler needed!

        function initializeConsole() {
            consoleElement = document.getElementById('console-content');
            
            // Capture console methods
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;
            const originalInfo = console.info;
            
            console.log = (...args) => {
                addConsoleMessage('log', args.join(' '));
                originalLog.apply(console, args);
            };
            
            console.warn = (...args) => {
                addConsoleMessage('warn', args.join(' '));
                originalWarn.apply(console, args);
            };
            
            console.error = (...args) => {
                addConsoleMessage('error', args.join(' '));
                originalError.apply(console, args);
                showConsole();
            };
            
            console.info = (...args) => {
                addConsoleMessage('info', args.join(' '));
                originalInfo.apply(console, args);
            };
            
            // Global error handler
            window.addEventListener('error', (event) => {
                console.error(`Runtime Error: ${event.message} at ${event.filename}:${event.lineno}`);
            });
            
            window.addEventListener('unhandledrejection', (event) => {
                console.error(`Unhandled Promise Rejection: ${event.reason}`);
            });
        }
        
        function setupEventListeners() {
            document.getElementById('build-button').addEventListener('click', buildScene);
            document.getElementById('run-button').addEventListener('click', runScene);
            document.getElementById('console-clear').addEventListener('click', clearConsole);
        }
        
        function addConsoleMessage(type, message) {
            if (!consoleElement) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = `console-${type}`;
            messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            consoleElement.appendChild(messageElement);
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }
        
        function showConsole() {
            document.getElementById('console').classList.add('show');
        }
        
        function hideConsole() {
            document.getElementById('console').classList.remove('show');
        }
        
        function clearConsole() {
            if (consoleElement) {
                consoleElement.innerHTML = '';
            }
            hideConsole();
        }
        
        function updateBuildStatus(status, message, type = '') {
            const statusElement = document.getElementById('build-status');
            const buildButton = document.getElementById('build-button');
            
            statusElement.textContent = message;
            statusElement.className = type ? `${type}` : '';
            
            buildButton.className = type || '';
            buildButton.disabled = type === 'building';
            
            if (type === 'building') {
                buildButton.textContent = 'Building...';
            } else {
                buildButton.textContent = 'Build';
            }
        }
        
        async function buildScene() {
            if (!editor) {
                console.error('Editor not initialized');
                return;
            }
            
            const code = editor.getValue();
            if (!code.trim()) {
                console.warn('No code to build');
                return;
            }
            
            updateBuildStatus('building', 'Building...', 'building');
            clearConsole();
            
            try {
                // Call Swift build service
                const result = await callSwiftBuildService(code);
                
                if (result.success) {
                    currentBundle = result.bundleCode;
                    updateBuildStatus('success', result.statusText, 'success');
                    console.log('‚úÖ Build completed successfully');
                    
                    // Auto-run for R3F
                    setTimeout(() => runBuiltScene(), 100);
                } else {
                    currentBundle = null;
                    updateBuildStatus('error', result.errors[0] || 'Build failed', 'error');
                    console.error('‚ùå Build failed:', result.errors.join(', '));
                    showConsole();
                }
                
            } catch (error) {
                currentBundle = null;
                updateBuildStatus('error', 'Build error', 'error');
                console.error('‚ùå Build error:', error);
                showConsole();
            }
        }
        
        function runScene() {
            console.log('üé¨ ANDROID DEBUG: runScene() called');
            console.log('üîç ANDROID DEBUG: currentBundle exists:', !!currentBundle);
            console.log('üîç ANDROID DEBUG: editor exists:', !!editor);
            console.log('üîç ANDROID DEBUG: editor content length:', editor ? editor.getValue().length : 'N/A');
            
            if (currentBundle) {
                console.log('üì¶ ANDROID DEBUG: Running built bundle scene...');
                runBuiltScene();
            } else {
                // Run the current editor content directly (for injected code)
                console.log('üìù ANDROID DEBUG: Running current editor content directly...');
                runCurrentEditorCode();
            }
        }
        
        function runCurrentEditorCode() {
            console.log('üìù ANDROID DEBUG: runCurrentEditorCode called');
            
            if (!editor) {
                console.error('‚ùå ANDROID DEBUG: Editor not available - trying default code...');
                
                // If no editor, try to run the default code directly
                const defaultCode = getDefaultCode();
                console.log('üîÑ ANDROID DEBUG: Using default code, length:', defaultCode.length);
                executeCodeDirectly(defaultCode);
                return;
            }
            
            const code = editor.getValue();
            if (!code.trim()) {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: No code in editor - using default code...');
                const defaultCode = getDefaultCode();
                executeCodeDirectly(defaultCode);
                return;
            }
            
            console.log('üìÑ ANDROID DEBUG: Editor code length:', code.length);
            
            executeCodeDirectlyInternal(code);
        }
        
        // Prevent infinite loops with global tracking - more robust initialization
        if (typeof window.isExecutingCode === 'undefined') {
            window.isExecutingCode = false;
            window.lastExecutionTime = 0;
            window.executionCallCount = 0;
        }
        
        function executeCodeDirectlyInternal(code) {
            const now = Date.now();
            window.executionCallCount++;
            
            console.log('üöÄ ANDROID DEBUG: executeCodeDirectlyInternal called with code length:', code.length);
            console.log('üìä ANDROID DEBUG: Call #' + window.executionCallCount + ', State:', {
                isExecuting: window.isExecutingCode,
                lastExecutionTime: window.lastExecutionTime,
                currentTime: now
            });
            
            // Calculate time since last execution (handle initial case)
            const timeSinceLastExecution = window.lastExecutionTime > 0 ? now - window.lastExecutionTime : 999999;
            console.log('üîç ANDROID DEBUG: Time since last execution:', timeSinceLastExecution + 'ms');
            
            // Prevent rapid repeated calls (less than 1 second apart)
            if (window.isExecutingCode) {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: Already executing code, ignoring call #' + window.executionCallCount);
                return;
            }
            
            if (window.lastExecutionTime > 0 && timeSinceLastExecution < 1000) {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: Too soon since last execution (' + timeSinceLastExecution + 'ms), ignoring call #' + window.executionCallCount);
                return;
            }
            
            console.log('‚úÖ ANDROID DEBUG: Proceeding with execution call #' + window.executionCallCount);
            window.isExecutingCode = true;
            window.lastExecutionTime = now;
            console.log('üîí ANDROID DEBUG: Setting execution lock at', now);
            
            // Safety timeout to prevent permanent lock
            setTimeout(() => {
                if (window.isExecutingCode) {
                    console.warn('‚ö†Ô∏è ANDROID DEBUG: Safety timeout - releasing stuck execution lock');
                    window.isExecutingCode = false;
                }
            }, 10000); // 10 second safety timeout
            
            // Check if libraries are ready, wait if not
            function checkAndRun(attempts = 0) {
                console.log(`üîç ANDROID DEBUG: checkAndRun attempt ${attempts + 1}`);
                const libraryStatus = {
                    React: !!window.React,
                    ReactDOM: !!window.ReactDOM,
                    ReactThreeFiber: !!window.ReactThreeFiber,
                    Drei: !!window.Drei,
                    THREE: !!window.THREE
                };
                
                console.log(`üîç ANDROID DEBUG: Libraries check attempt ${attempts}:`, libraryStatus);
                
                const allReady = libraryStatus.React && libraryStatus.ReactDOM && libraryStatus.ReactThreeFiber;
                
                if (allReady || attempts >= 10) {
                    if (!allReady) {
                        console.warn('‚ö†Ô∏è ANDROID DEBUG: Proceeding with incomplete libraries after 10 attempts');
                    }
                    executeCode();
                } else {
                    console.log(`‚è≥ ANDROID DEBUG: Libraries not ready, waiting... (attempt ${attempts + 1}/10)`);
                    setTimeout(() => checkAndRun(attempts + 1), 500);
                }
            }
            
            async function executeCode() {
                try {
                    // Hide loading overlay when execution starts
                    const loadingOverlay = document.getElementById('loading-overlay');
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }

                    // Clear the root element
                    const root = document.getElementById('root');
                    root.innerHTML = '';

                    // ========================================
                    // REAL R3F + BABEL TRANSFORMATION (iOS version approach)
                    // ========================================
                    console.log('üîÑ ANDROID DEBUG: Using REAL R3F with Babel transformation...');
                    console.log('   R3F loaded:', !!window.ReactThreeFiber);
                    console.log('   Drei loaded:', !!window.Drei);

                    // ========================================
                    // FALLBACK: BABEL TRANSFORMATION
                    // ========================================
                    // Transform the code to replace imports with global variables AND JSX
                    console.log('üîÑ ANDROID DEBUG: Transforming import statements and JSX...');
                    let transformedCode = code;
                    
                    // Replace ES6 imports with global variable assignments
                    transformedCode = transformedCode
                        .replace(/import\s+React[^'"]*from\s+['"]react['"];?\s*/g, 'const React = window.React;\n')
                        .replace(/import\s+\{([^}]+)\}\s+from\s+['"]react['"];?\s*/g, 'const {$1} = window.React;\n')
                        .replace(/import\s+\{([^}]+)\}\s+from\s+['"]react-dom\/client['"];?\s*/g, 'const {$1} = window.ReactDOM;\n')
                        .replace(/import\s+\{([^}]+)\}\s+from\s+['"]@react-three\/fiber['"];?\s*/g, 'const {$1} = window.ReactThreeFiber;\n')
                        .replace(/import\s+\{([^}]+)\}\s+from\s+['"]@react-three\/drei['"];?\s*/g, 'const {$1} = window.Drei;\n')
                        .replace(/import\s+\*\s+as\s+THREE\s+from\s+['"]three['"];?\s*/g, 'const THREE = window.THREE;\n')
                        .replace(/import\s+THREE\s+from\s+['"]three['"];?\s*/g, 'const THREE = window.THREE;\n');

                    // ‚úÖ DISABLED: Manual TypeScript removal completely disabled
                    // Babel's @babel/preset-typescript handles ALL TypeScript syntax properly
                    // The manual regex approach was DESTROYING code by over-aggressive pattern matching
                    if (false) { // PERMANENTLY DISABLED - DO NOT RE-ENABLE
                    console.log('üîß ANDROID DEBUG: Manual TypeScript removal (NOTE: Babel preset-typescript now handles this)...');
                    const codeBeforeTS = transformedCode;

                    // First, remove interface and type declarations (must be done BEFORE Babel)
                    console.log('üîß ANDROID DEBUG: Removing interface and type declarations...');
                    const interfaceMatches = transformedCode.match(/interface\s+\w+(\s+extends\s+[\w\s,]+)?\s*\{[\s\S]*?\}/g);
                    if (interfaceMatches) {
                        console.log(`   Found ${interfaceMatches.length} interface(s) to remove:`);
                        interfaceMatches.forEach((iface, idx) => {
                            // Show first line only for brevity
                            const firstLine = iface.split('\n')[0];
                            console.log(`   ${idx + 1}. ${firstLine}...`);
                        });
                    }
                    const typeMatches = transformedCode.match(/type\s+\w+\s*=\s*(\{[\s\S]*?\}\s*;?|[^;\n{]+;)/g);
                    if (typeMatches) {
                        console.log(`   Found ${typeMatches.length} type declaration(s) to remove:`);
                        typeMatches.forEach((t, idx) => {
                            const firstLine = t.split('\n')[0];
                            console.log(`   ${idx + 1}. ${firstLine}...`);
                        });
                    }

                    transformedCode = transformedCode
                        // Remove interface declarations (single or multi-line, with optional extends)
                        .replace(/interface\s+\w+(\s+extends\s+[\w\s,]+)?\s*\{[\s\S]*?\}/g, '')
                        // Remove type declarations - object types: type Name = { ... } (with or without semicolon)
                        .replace(/type\s+\w+\s*=\s*\{[\s\S]*?\}\s*;?/g, '')
                        // Remove type declarations - other types: type Name = something;
                        .replace(/type\s+\w+\s*=\s*[^;\n{]+;/g, '')
                        // Remove object type literals: : { prop: type } or : { prop }
                        .replace(/:\s*\{[^}]*\}/g, '')
                        // Remove array types: : Type[] or : Array<Type>
                        .replace(/:\s*Array<[^>]+>/g, '')
                        .replace(/:\s*[A-Z][A-Za-z0-9\[\]<>\.]*(\s*\[\])?/g, '')
                        // Remove primitive types: : string, : number, : boolean, etc.
                        .replace(/:\s*(string|number|boolean|any|void|null|undefined|never|unknown)(\[\])?/g, '')
                        // Remove union types: : Type1 | Type2
                        .replace(/:\s*[A-Za-z0-9_]+(\s*\|\s*[A-Za-z0-9_]+)+/g, '')
                        // Remove function types: : () => Type
                        .replace(/:\s*\([^)]*\)\s*=>\s*[A-Za-z0-9_<>\[\]]+/g, '')
                        // Remove generic types from hooks - do this line by line to avoid issues
                        // Split into lines, process each line, then rejoin
                        ;
                    const linesForGenerics = transformedCode.split('\n');
                    transformedCode = linesForGenerics.map(line => {
                        // For each line, remove hook generics by finding < and matching >
                        // Handle: useRef<Type>, React.useState<Type>, window.React.useMemo<Array<Type>>
                        const hooks = ['useRef', 'useState', 'useCallback', 'useMemo', 'useEffect', 'useContext', 'useReducer'];
                        hooks.forEach(hook => {
                            // Match hook name (with optional React./window.React. prefix) followed by optional space and <
                            const prefixes = [hook, `React.${hook}`, `window.React.${hook}`];
                            prefixes.forEach(prefix => {
                                const idx = line.indexOf(prefix);
                                if (idx !== -1) {
                                    const afterHook = line.substring(idx + prefix.length);
                                    // Check if there's a < after optional whitespace
                                    const match = afterHook.match(/^(\s*)<(.*)$/);
                                    if (match) {
                                        const spaces = match[1];
                                        const rest = match[2];
                                        // Find matching >
                                        let depth = 1;
                                        let endIdx = -1;
                                        for (let i = 0; i < rest.length; i++) {
                                            if (rest[i] === '<') depth++;
                                            if (rest[i] === '>') {
                                                depth--;
                                                if (depth === 0) {
                                                    endIdx = i;
                                                    break;
                                                }
                                            }
                                        }
                                        if (endIdx !== -1) {
                                            // Remove the <...> part
                                            const before = line.substring(0, idx + prefix.length);
                                            const after = rest.substring(endIdx + 1);
                                            line = before + after;
                                        }
                                    }
                                }
                            });
                        });
                        return line;
                    }).join('\n');
                    transformedCode = transformedCode
                        // Remove 'as Type' casting
                        .replace(/as\s+[A-Z][A-Za-z0-9\[\]<>\.]*(\s*\[\])?/g, '')
                        .replace(/as\s+(string|number|boolean|any)/g, '')
                        // Remove tuple type assertions: as [type, type, type]
                        .replace(/as\s+\[[^\]]+\]/g, '')
                        // Remove const assertions: as const
                        .replace(/as\s+const/g, '')
                        // Remove angle bracket type assertions (old TypeScript): <Type>value
                        .replace(/<([A-Z][A-Za-z0-9_]*(?:\[\])?)>\s*(?=\(|[a-z_])/g, '')
                        // Remove non-null assertions: value! (but preserve logical NOT)
                        .replace(/([a-zA-Z0-9_\)\]]+)!/g, '$1')
                        // Remove interface declarations (single or multi-line, with optional extends)
                        .replace(/interface\s+\w+(\s+extends\s+[\w\s,]+)?\s*\{[\s\S]*?\}/g, '')
                        // Remove type declarations (single or multi-line)
                        .replace(/type\s+\w+\s*=\s*[\s\S]*?;/g, '')
                        // Remove readonly modifiers
                        .replace(/readonly\s+/g, '')
                        // Remove optional chaining type assertions: !.
                        .replace(/!\.(?=[a-zA-Z_])/g, '.');

                    // Calculate how much TypeScript was stripped
                    const tsCharsRemoved = codeBeforeTS.length - transformedCode.length;
                    console.log('‚úÖ ANDROID DEBUG: TypeScript syntax stripped');
                    console.log(`   üìä Removed ${tsCharsRemoved} characters of TypeScript syntax`);

                    // üîß FIX MALFORMED OBJECT PROPERTIES: Only fix obvious malformed patterns
                    console.log('üîß ANDROID DEBUG: Fixing malformed object properties...');
                    const linesForFix = transformedCode.split('\n');
                    transformedCode = linesForFix.map(line => {
                        // Only fix lines that look like object properties with malformed syntax
                        // Pattern: "propertyName:" followed by "word() * number" where word is NOT "Math.random"
                        // This prevents breaking valid Math.random() calls

                        // Skip lines with valid Math.random() calls
                        if (line.includes('Math.random()')) {
                            return line;
                        }

                        // Fix malformed property syntax Pattern 1: "delay() * 3" -> "delay: Math.random() * 3"
                        line = line.replace(
                            /(\s+)([a-z]\w+)\(\)\s*\*\s*(\d+)/g,
                            '$1$2: Math.random() * $3'
                        );

                        // Fix malformed property syntax Pattern 2: "life()," -> "life: Math.random(),"
                        // This handles function calls used as object properties
                        line = line.replace(
                            /(\s+)([a-z]\w+)\(\)\s*,/g,
                            '$1$2: Math.random(),'
                        );

                        return line;
                    }).join('\n');
                    console.log('‚úÖ ANDROID DEBUG: Malformed properties fixed');

                    // Show specific lines that changed (sample around line 88 where error was)
                    if (tsCharsRemoved > 0) {
                        const beforeLines = codeBeforeTS.split('\n');
                        const afterLines = transformedCode.split('\n');
                        console.log('   üîç Sample TypeScript removal (lines 85-92):');
                        for (let i = 84; i < Math.min(92, beforeLines.length); i++) {
                            if (beforeLines[i] !== afterLines[i]) {
                                console.log(`   BEFORE ${i+1}: ${beforeLines[i]}`);
                                console.log(`   AFTER  ${i+1}: ${afterLines[i]}`);
                            }
                        }
                    }

                    console.log('üìù ANDROID DEBUG: Code after TS removal (first 300 chars):', transformedCode.substring(0, 300));
                    } // End of DISABLED manual TypeScript removal block

                    // ‚úÖ Babel's TypeScript preset handles all TypeScript syntax automatically
                    console.log('‚úÖ ANDROID DEBUG: Skipping manual TypeScript removal - Babel preset-typescript will handle it');
                    console.log('üìù ANDROID DEBUG: Code before Babel (first 300 chars):', transformedCode.substring(0, 300));

                    // üîß CRITICAL FIX: Transform JSX using Babel
                    // Check for JSX - look for React component syntax like <Canvas or <mesh
                    const hasJSX = /<[A-Z]/.test(transformedCode) || /<[a-z]+\s/.test(transformedCode);
                    const hasBrackets = transformedCode.includes('<') && transformedCode.includes('>');

                    console.log('üîç ANDROID DEBUG: JSX detection:', {
                        hasJSX: hasJSX,
                        hasBrackets: hasBrackets,
                        babelAvailable: typeof Babel !== 'undefined',
                        babelTransform: typeof Babel?.transform,
                        codeLength: transformedCode.length,
                        firstJSXMatch: transformedCode.match(/<[A-Za-z][^>]*>/)?.[0] || 'none'
                    });

                    if (hasJSX || hasBrackets) {
                        console.log('üéØ ANDROID DEBUG: JSX/HTML detected, transforming with Babel...');
                        console.log('üìù ANDROID DEBUG: Code before Babel (first 300 chars):', transformedCode.substring(0, 300));

                        try {
                            if (typeof Babel !== 'undefined' && Babel.transform) {
                                console.log('‚úÖ ANDROID DEBUG: Babel is available, starting transformation...');
                                const babelResult = Babel.transform(transformedCode, {
                                    presets: [
                                        'react',
                                        ['typescript', {
                                            isTSX: true,
                                            allExtensions: true,
                                            onlyRemoveTypeImports: true
                                        }]
                                    ],
                                    filename: 'scene.tsx'  // Changed to .tsx to enable TypeScript
                                });
                                transformedCode = babelResult.code;
                                console.log('‚úÖ ANDROID DEBUG: Babel JSX + TypeScript transformation successful');
                                console.log('üìù ANDROID DEBUG: Code after Babel (first 300 chars):', transformedCode.substring(0, 300));

                                // ========================================
                                // R3F PRIMITIVE ELEMENT REPLACEMENT
                                // ========================================
                                // Replace React.createElement('mesh', ...) with React.createElement(window.mesh, ...)
                                // This is needed because Babel transforms <mesh> to createElement('mesh', ...)
                                // but React treats lowercase strings as DOM elements
                                console.log('üîß ANDROID DEBUG: Replacing R3F primitive createElement calls...');

                                const r3fPrimitives = [
                                    // Object primitives
                                    'mesh', 'group', 'points', 'line', 'lineSegments', 'instancedMesh',
                                    // Geometries
                                    'sphereGeometry', 'boxGeometry', 'planeGeometry', 'cylinderGeometry',
                                    'coneGeometry', 'torusGeometry', 'ringGeometry', 'icosahedronGeometry', 'octahedronGeometry',
                                    'dodecahedronGeometry', 'tetrahedronGeometry', 'bufferGeometry', 'bufferAttribute',
                                    // Materials
                                    'meshBasicMaterial', 'meshStandardMaterial', 'meshPhongMaterial',
                                    'meshLambertMaterial', 'meshPhysicalMaterial', 'meshToonMaterial',
                                    'meshNormalMaterial', 'meshDepthMaterial', 'pointsMaterial',
                                    'lineBasicMaterial', 'lineDashedMaterial', 'shaderMaterial', 'rawShaderMaterial',
                                    // Lights
                                    'ambientLight', 'pointLight', 'directionalLight', 'spotLight', 'hemisphereLight',
                                    // Special
                                    'color'
                                ];

                                r3fPrimitives.forEach(primitive => {
                                    // Match React.createElement('primitiveName', ...) and replace with React.createElement(window.primitiveName, ...)
                                    // This regex handles the /*#__PURE__*/ comment that Babel adds
                                    const regex = new RegExp(`(\/\\*#__PURE__\\*\\/)?React\\.createElement\\("${primitive}"`, 'g');
                                    const beforeCount = (transformedCode.match(regex) || []).length;

                                    if (beforeCount > 0) {
                                        transformedCode = transformedCode.replace(regex, (match) => {
                                            if (match.includes('/*#__PURE__*/')) {
                                                return `/*#__PURE__*/React.createElement(window.${primitive}`;
                                            }
                                            return `React.createElement(window.${primitive}`;
                                        });
                                        console.log(`   ‚úì Replaced ${beforeCount} instances of "${primitive}"`);
                                    }
                                });

                                console.log('‚úÖ ANDROID DEBUG: R3F primitive replacement complete');

                                // ========================================
                                // FIX BARE HOOK CALLS (AFTER BABEL)
                                // ========================================
                                // Babel has now transformed JSX, but bare hook calls like useRef() need to be React.useRef()
                                console.log('üîß ANDROID DEBUG: Fixing bare hook calls after Babel...');

                                // Count before
                                const bareHooksBefore = (transformedCode.match(/\buseRef\(/g) || []).length;

                                transformedCode = transformedCode
                                    // React hooks - add React. prefix if not already present
                                    // Use negative lookbehind to avoid matching React.useRef or window.React.useRef
                                    .replace(/(?<!React\.)(?<!window\.React\.)\b(useRef|useState|useEffect|useCallback|useMemo|useContext|useReducer|useLayoutEffect|useImperativeHandle)\(/g, 'React.$1(');

                                const bareHooksAfter = (transformedCode.match(/\buseRef\(/g) || []).length;
                                console.log(`   ‚úì Fixed ${bareHooksBefore - bareHooksAfter} bare hook calls`);
                                console.log('‚úÖ ANDROID DEBUG: Bare hook calls fixed');

                            } else {
                                console.error('‚ùå ANDROID DEBUG: Babel not available!');
                                console.error('   typeof Babel:', typeof Babel);
                                console.error('   Babel object:', Babel);
                                throw new Error('Babel standalone library not loaded');
                            }
                        } catch (babelError) {
                            console.error('‚ùå ANDROID DEBUG: Babel transformation failed:', babelError);
                            console.error('   Error name:', babelError.name);
                            console.error('   Error message:', babelError.message);
                            console.error('   Error stack:', babelError.stack);

                            // üîç ENHANCED ERROR REPORTING: Show code around the error line
                            const errorMatch = babelError.message.match(/\((\d+):(\d+)/);
                            if (errorMatch) {
                                const errorLine = parseInt(errorMatch[1]);
                                const errorCol = parseInt(errorMatch[2]);
                                const codeLines = transformedCode.split('\n');

                                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                                console.error('üîç CODE CONTEXT AROUND ERROR:');
                                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

                                // Show 5 lines before and after the error
                                const startLine = Math.max(0, errorLine - 6);
                                const endLine = Math.min(codeLines.length - 1, errorLine + 4);

                                for (let i = startLine; i <= endLine; i++) {
                                    const lineNum = (i + 1).toString().padStart(4, ' ');
                                    const marker = (i + 1 === errorLine) ? '>>> ' : '    ';
                                    console.error(`${marker}${lineNum} | ${codeLines[i]}`);

                                    // Show error pointer on the error line
                                    if (i + 1 === errorLine) {
                                        const pointer = ' '.repeat(9 + errorCol) + '^';
                                        console.error(`    ${pointer} ERROR HERE`);
                                    }
                                }

                                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                                console.error(`üí° HINT: Check line ${errorLine}, column ${errorCol}`);
                                console.error('   Common fixes:');
                                console.error('   - Add missing comma between object properties');
                                console.error('   - Close unclosed JSX tags or brackets');
                                console.error('   - Remove TypeScript syntax (types, interfaces)');
                                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                            }

                            throw babelError; // Don't continue with broken JSX
                        }
                    } else {
                        console.log('‚ÑπÔ∏è ANDROID DEBUG: No JSX detected, skipping Babel transformation');
                    }

                    // üîß CRITICAL FIX: Remove export statements AFTER Babel transformation
                    console.log('üîß ANDROID DEBUG: Removing export statements...');
                    transformedCode = transformedCode
                        .replace(/export\s+default\s+.*;?\s*$/gm, '') // Remove any "export default ..." statement
                        .replace(/export\s+\{[^}]+\}\s*;?\s*$/gm, '') // Remove "export { Component };"
                        .replace(/export\s+(const|let|var|function|class)\s+/g, '$1 '); // Change "export const" to "const"

                    // Also remove any stray [RUN_SCENE] or similar artifacts
                    transformedCode = transformedCode
                        .replace(/\[RUN_SCENE\]/g, '') // Remove [RUN_SCENE] artifacts
                        .trim(); // Remove leading/trailing whitespace

                    // üîß AUTO-EXPOSE COMPONENTS: Find function/const declarations and expose to window
                    console.log('üîß ANDROID DEBUG: Auto-exposing component definitions to window...');

                    // Find all function declarations and expose them to window
                    transformedCode = transformedCode.replace(
                        /^(function\s+([A-Z][a-zA-Z0-9]*)\s*\()/gm,
                        'window.$2 = $1'
                    );

                    // Find all const/let component declarations (PascalCase = likely React components)
                    // But skip lines that are already destructuring or importing from window
                    const lines = transformedCode.split('\n');
                    transformedCode = lines.map(line => {
                        // Skip lines that are already window.* assignments or destructuring
                        if (line.includes('window.') || line.includes('{')) {
                            return line;
                        }
                        // Only expose PascalCase const/let assignments
                        return line.replace(
                            /^(const|let)\s+([A-Z][a-zA-Z0-9]*)\s*=/,
                            '$1 $2 = window.$2 ='
                        );
                    }).join('\n');

                    console.log('‚úÖ ANDROID DEBUG: Component auto-exposure complete');

                    // Debug the transformed code before execution
                    console.log('üîç ANDROID DEBUG: Complete transformed code:');
                    console.log('--- START TRANSFORMED CODE ---');
                    console.log(transformedCode);
                    console.log('--- END TRANSFORMED CODE ---');
                    
                    // Debug: Check transformed code stats
                    console.log('üîç ANDROID DEBUG: Transformed code stats:', {
                        length: transformedCode.length,
                        firstChar: transformedCode[0],
                        first50: transformedCode.substring(0, 50),
                        containsJSX: transformedCode.includes('React.createElement'),
                        containsRawJSX: (transformedCode.match(/<[A-Z]/g) || []).length > 0
                    });

                    console.log('‚úÖ ANDROID DEBUG: Code transformed, executing...');

                    // Use Function constructor for reliable execution
                    try {
                        console.log('üöÄ ANDROID DEBUG: Creating execution function...');

                        // Verify libraries
                        if (!window.React || !window.ReactDOM || !window.ReactThreeFiber) {
                            throw new Error('Required libraries not loaded');
                        }

                        // Store existing globals before execution
                        const beforeGlobals = new Set(Object.keys(window));

                        // Execute code using Function constructor (more reliable than eval)
                        const executeCode = new Function(transformedCode);
                        executeCode.call(window);

                        console.log('‚úÖ ANDROID DEBUG: User code executed successfully');

                        // Debug: Check what new globals were created
                        const afterGlobals = Object.keys(window);
                        const newGlobals = afterGlobals.filter(key => !beforeGlobals.has(key));
                        console.log('üîç ANDROID DEBUG: New globals created by user code:', newGlobals);

                        // Debug: Check if any functions were created (potential components)
                        const newFunctions = newGlobals.filter(key => typeof window[key] === 'function');
                        console.log('üîç ANDROID DEBUG: New functions (potential components):', newFunctions);

                        // Check if the code already rendered something (by checking if root has children)
                        const root = document.getElementById('root');
                        if (!root) {
                            console.error('‚ùå ANDROID DEBUG: Root element not found!');
                            return;
                        }

                        // Give the code a moment to render (in case it uses createRoot itself)
                        setTimeout(() => {
                            // Check if root element has any React content
                            if (root.children.length > 0 || root._reactRootContainer || root._reactRoot) {
                                console.log('‚úÖ ANDROID DEBUG: Code has already rendered content to root element');
                                return;
                            }

                            // Auto-render main component if code didn't render anything
                            // Priority 1: Try common component names
                            const componentNames = ['App', 'Scene', 'DiscoRaveScene', 'Main', 'Root', 'Experience', 'Solarium', 'SolarSystem'];
                            let MainComponent = null;
                            let componentName = null;

                            for (const name of componentNames) {
                                if (typeof window[name] === 'function') {
                                    MainComponent = window[name];
                                    componentName = name;
                                    console.log('üéØ ANDROID DEBUG: Found standard component:', name);
                                    break;
                                }
                            }

                            // Priority 2: If no standard component found, try any new PascalCase function
                            // Prefer LAST component (conventionally the main export/app component)
                            if (!MainComponent && newFunctions.length > 0) {
                                console.log('üîç ANDROID DEBUG: No standard component, trying new functions:', newFunctions);

                                // Filter to only PascalCase functions (likely components)
                                const potentialComponents = newFunctions.filter(name =>
                                    /^[A-Z]/.test(name) && typeof window[name] === 'function'
                                );

                                console.log('üîç ANDROID DEBUG: Potential components found:', potentialComponents);

                                if (potentialComponents.length > 0) {
                                    // Pick the LAST component (conventionally the main one)
                                    componentName = potentialComponents[potentialComponents.length - 1];
                                    MainComponent = window[componentName];
                                    console.log('üéØ ANDROID DEBUG: Selected last component as main:', componentName);
                                }
                            }

                            if (MainComponent) {
                                console.log('‚úÖ ANDROID DEBUG: Auto-rendering component: ' + componentName);
                                try {
                                    const reactRoot = window.ReactDOM.createRoot(root);
                                    reactRoot.render(window.React.createElement(MainComponent));
                                    console.log('‚úÖ ANDROID DEBUG: Component rendered successfully');
                                } catch (renderError) {
                                    console.error('‚ùå ANDROID DEBUG: Auto-render failed:', renderError);
                                }
                            } else {
                                console.warn('‚ö†Ô∏è ANDROID DEBUG: No main component found for auto-render.');
                                console.warn('   If your code calls createRoot/render itself, this is normal.');
                                console.warn('   Otherwise, expose your component to window (e.g., window.App = App)');
                            }
                        }, 100);

                    } catch (error) {
                        console.error('‚ùå ANDROID DEBUG: Execution error:', error.name, error.message);
                        console.error('üìä ANDROID DEBUG: Stack:', error.stack);
                        console.error('üîç ANDROID DEBUG: Code preview:', transformedCode.substring(0, 200));
                        throw error;
                    }

                    console.log('‚úÖ ANDROID DEBUG: Code execution completed');

                    // Reset execution lock after successful execution
                    setTimeout(() => {
                        window.isExecutingCode = false;
                        console.log('üîì ANDROID DEBUG: Execution lock released');
                    }, 500);
                    
                } catch (error) {
                    console.error('‚ùå ANDROID DEBUG: Runtime error in executeCode:', error);
                    window.isExecutingCode = false; // Reset lock on error
                    console.log('üîì ANDROID DEBUG: Execution lock released (error case)');
                    showFallbackScene(error);
                    showConsole();
                }
            }
            
            // Start the check and run process
            checkAndRun();
        }
        
        // üîß CRITICAL FIX: Working Rainbow code without JSX
        function getWorkingRainbowCode() {
            return `
const React = window.React;
const { createRoot } = window.ReactDOM;
const { Canvas, useFrame } = window.ReactThreeFiber;
const { OrbitControls } = window.Drei;
const THREE = window.THREE;

function Rainbow() {
  console.log('üéØ ANDROID DEBUG: Rainbow component rendering...');
  
  window.React.useEffect(() => {
    if (!window.currentScene) {
      console.warn('‚ö†Ô∏è ANDROID DEBUG: Scene not ready for rainbow');
      return;
    }
    
    console.log('üåà ANDROID DEBUG: Creating rainbow meshes directly in scene...');
    
    const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
    const segments = 7;
    const radius = 3;
    const height = 2;
    const meshes = [];

    colors.forEach((color, index) => {
      const angle = (Math.PI / 2) - (Math.PI / segments * index);
      const x = radius * Math.cos(angle);
      const y = 0;
      const z = radius * Math.sin(angle);

      console.log(\`üåà ANDROID DEBUG: Creating \${color} segment at position [\${x.toFixed(2)}, \${y}, \${z.toFixed(2)}]\`);

      // Create geometry and material
      const geometry = new window.THREE.BoxGeometry(0.3, height, 0.3);
      const material = new window.THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.3,
        metalness: 0.1
      });

      // Create mesh
      const mesh = new window.THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      mesh.rotation.set(0, 0, angle);

      // Add to scene
      window.currentScene.add(mesh);
      meshes.push(mesh);

      console.log(\`‚úÖ ANDROID DEBUG: \${color} segment added to scene at\`, mesh.position);
    });

    console.log('‚úÖ ANDROID DEBUG: All rainbow segments added to scene');
    console.log('üîç ANDROID DEBUG: Scene children count:', window.currentScene.children.length);
    
    // Cleanup function
    return () => {
      meshes.forEach(mesh => {
        window.currentScene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      });
    };
  }, []);

  return null; // No React elements needed, we're adding directly to Three.js scene
}

function Scene() {
  console.log('üéØ ANDROID DEBUG: Scene component rendering...');
  
  // Use useEffect to add lights and objects directly to the Three.js scene
  window.React.useEffect(() => {
    if (!window.currentScene) {
      console.warn('‚ö†Ô∏è ANDROID DEBUG: Scene not ready for lights');
      return;
    }
    
    console.log('üí° ANDROID DEBUG: Adding lights to scene...');
    
    // Create and add ambient light
    const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.6);
    window.currentScene.add(ambientLight);
    console.log('‚úÖ ANDROID DEBUG: Ambient light added to scene');
    
    // Create and add directional light
    const directionalLight = new window.THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    window.currentScene.add(directionalLight);
    console.log('‚úÖ ANDROID DEBUG: Directional light added to scene');
    
    // Create and add point light
    const pointLight = new window.THREE.PointLight(0xffffff, 0.5);
    pointLight.position.set(-5, 5, -5);
    window.currentScene.add(pointLight);
    console.log('‚úÖ ANDROID DEBUG: Point light added to scene');
    
    // Cleanup function
    return () => {
      window.currentScene.remove(ambientLight);
      window.currentScene.remove(directionalLight);
      window.currentScene.remove(pointLight);
    };
  }, []);
  
  return React.createElement(React.Fragment, null,
    React.createElement(Rainbow),
    React.createElement(OrbitControls)
  );
}

function App() {
  console.log('üéØ ANDROID DEBUG: App component rendering...');
  console.log('üîç ANDROID DEBUG: Canvas component:', typeof Canvas);
  
  return React.createElement(Canvas, {
    style: { 
      width: '100%', 
      height: '100%',
      display: 'block',
      background: '#1a1a2e'
    },
    camera: { position: [0, 0, 8], fov: 75 },
    gl: { antialias: true },
    onCreated: ({ gl, scene, camera }) => {
      console.log('‚úÖ ANDROID DEBUG: Canvas created successfully!');
      console.log('üîç ANDROID DEBUG: WebGL context:', !!gl);
      console.log('üîç ANDROID DEBUG: Scene:', !!scene);
      console.log('üîç ANDROID DEBUG: Camera position:', camera.position);
    }
  },
    React.createElement(Scene)
  );
}

console.log('üéØ ANDROID DEBUG: Looking for root element...');
const rootElement = document.getElementById('root');
console.log('üîç ANDROID DEBUG: Root element found:', !!rootElement);
console.log('üîç ANDROID DEBUG: Root element details:', {
  exists: !!rootElement,
  tagName: rootElement?.tagName,
  style: rootElement?.style.cssText,
  clientWidth: rootElement?.clientWidth,
  clientHeight: rootElement?.clientHeight
});

if (rootElement) {
  console.log('üéØ ANDROID DEBUG: Creating React root...');
  
  try {
    const root = createRoot(rootElement);
    console.log('üéØ ANDROID DEBUG: React root created successfully');
    
    console.log('üéØ ANDROID DEBUG: Rendering App component...');
    root.render(React.createElement(App));
    console.log('‚úÖ ANDROID DEBUG: App component render call completed');
    
    // Fallback: if React Three Fiber fails, create direct Three.js scene
    setTimeout(() => {
      console.log('‚è∞ ANDROID DEBUG: Checking if scene rendered after 2 seconds...');
      if (!window.currentScene || window.currentScene.children.length === 0) {
        console.warn('‚ö†Ô∏è ANDROID DEBUG: React Three Fiber failed, creating direct Three.js scene...');
        createDirectThreeJSScene(rootElement);
      } else {
        console.log('‚úÖ ANDROID DEBUG: React Three Fiber scene found with', window.currentScene.children.length, 'children');
      }
    }, 2000);
    
  } catch (error) {
    console.error('‚ùå ANDROID DEBUG: Error creating React root or rendering:', error);
    console.log('üîÑ ANDROID DEBUG: Falling back to direct Three.js implementation...');
    createDirectThreeJSScene(rootElement);
  }
} else {
  console.error('‚ùå ANDROID DEBUG: Root element not found!');
}

// üîß FALLBACK: Direct Three.js implementation without React
function createDirectThreeJSScene(container) {
  console.log('üéØ ANDROID DEBUG: Creating direct Three.js scene without React...');
  
  try {
    // Clear container
    container.innerHTML = '';
    
    // Create canvas
    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    container.appendChild(canvas);
    
    console.log('üé® ANDROID DEBUG: Canvas created and added to DOM');
    
    // Create Three.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x1a1a2e, 1);
    
    console.log('üé® ANDROID DEBUG: Three.js renderer created');
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    
    console.log('üí° ANDROID DEBUG: Lights added to scene');
    
    // Create rainbow
    const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
    const segments = 7;
    const radius = 3;
    const height = 2;
    
    colors.forEach((color, index) => {
      const angle = (Math.PI / 2) - (Math.PI / segments * index);
      const x = radius * Math.cos(angle);
      const y = 0;
      const z = radius * Math.sin(angle);
      
      const geometry = new THREE.BoxGeometry(0.3, height, 0.3);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      
      mesh.position.set(x, y, z);
      mesh.rotation.set(0, 0, angle);
      scene.add(mesh);
      
      console.log(\`üåà ANDROID DEBUG: Added \${color} segment to direct scene\`);
    });
    
    // Position camera
    camera.position.set(0, 0, 8);
    
    console.log('‚úÖ ANDROID DEBUG: Direct Three.js scene created with', scene.children.length, 'objects');
    
    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
    
    console.log('üöÄ ANDROID DEBUG: Direct Three.js animation started');
    
    // Store globally for debugging
    window.currentScene = scene;
    window.currentCamera = camera;
    window.currentRenderer = renderer;
    
  } catch (error) {
    console.error('‚ùå ANDROID DEBUG: Direct Three.js scene creation failed:', error);
    container.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Failed to create 3D scene. Check console for errors.</div>';
  }
}
`;
        }

        // üîß CRITICAL FIX: Simple JSX replacement for basic patterns
        function convertJSXSimple(code) {
            console.log('üéØ ANDROID DEBUG: Starting simple JSX conversion...');
            
            let converted = code;
            
            // First, let's just handle the most common JSX patterns manually
            // This is much more reliable than complex regex
            
            // Handle React fragments
            converted = converted.replace(/<>\s*/g, 'React.createElement(React.Fragment, null, ');
            converted = converted.replace(/\s*<\/>/g, ')');
            
            // Handle common self-closing tags
            converted = converted.replace(/<(\w+)\s*\/>/g, 'React.createElement(\'$1\', null)');
            
            // Handle basic JSX with props but no children (simplified)
            converted = converted.replace(/<(\w+)\s+([^>]+?)\s*\/>/g, (match, tagName, props) => {
                // Very basic prop conversion - just pass as object
                const cleanProps = props.replace(/(\w+)=\{([^}]+)\}/g, '$1: $2').replace(/(\w+)="([^"]+)"/g, '$1: "$2"');
                return `React.createElement('${tagName}', {${cleanProps}})`;
            });
            
            console.log('‚úÖ ANDROID DEBUG: Simple JSX conversion completed');
            console.log('üîç ANDROID DEBUG: Converted code sample:', converted.substring(0, 300) + '...');
            
            return converted;
        }

        // üîß CRITICAL FIX: Enhanced JSX to React.createElement() converter (DISABLED)
        function convertJSXToReactCreateElement(code) {
            console.log('üéØ ANDROID DEBUG: Starting enhanced JSX conversion...');
            
            let converted = code;
            
            // First handle JSX fragments <> ... </>
            converted = converted.replace(/<>\s*([\s\S]*?)\s*<\/>/g, (match, content) => {
                return `React.createElement(React.Fragment, null, ${content.trim()})`;
            });
            
            // Handle nested JSX more carefully - start with innermost tags
            let lastConverted;
            let iterations = 0;
            do {
                lastConverted = converted;
                iterations++;
                
                // Convert self-closing tags like <mesh position={[0, 0, 0]} />
                converted = converted.replace(/<(\w+)(\s[^>\/]*?)?\s*\/>/g, (match, tagName, attrs) => {
                    const props = attrs ? parseEnhancedJSXProps(attrs) : 'null';
                    return `React.createElement('${tagName}', ${props})`;
                });
                
                // Convert simple tags with text content like <div>text</div>
                converted = converted.replace(/<(\w+)(\s[^>]*?)?>([^<]+)<\/\1>/g, (match, tagName, attrs, content) => {
                    const props = attrs ? parseEnhancedJSXProps(attrs) : 'null';
                    const textContent = content.trim();
                    if (textContent && !textContent.includes('React.createElement')) {
                        return `React.createElement('${tagName}', ${props}, "${textContent}")`;
                    }
                    return match; // Don't convert if content contains React.createElement
                });
                
                // Convert tags with React element children
                converted = converted.replace(/<(\w+)(\s[^>]*?)?>(\s*React\.createElement[\s\S]*?)\s*<\/\1>/g, (match, tagName, attrs, children) => {
                    const props = attrs ? parseEnhancedJSXProps(attrs) : 'null';
                    return `React.createElement('${tagName}', ${props}, ${children.trim()})`;
                });
                
            } while (converted !== lastConverted && iterations < 10); // Prevent infinite loops
            
            console.log('‚úÖ ANDROID DEBUG: JSX conversion completed after', iterations, 'iterations');
            console.log('üîç ANDROID DEBUG: Converted code sample:', converted.substring(0, 300) + '...');
            
            return converted;
        }
        
        function parseEnhancedJSXProps(attrString) {
            if (!attrString || !attrString.trim()) return 'null';
            
            const cleanAttrs = attrString.trim();
            let props = '{';
            
            // Handle JSX expression attributes like position={[0, 1, 0]}
            const expressionMatches = cleanAttrs.matchAll(/(\w+)=\{([^}]+)\}/g);
            for (const match of expressionMatches) {
                const [, propName, expression] = match;
                props += `${propName}: ${expression}, `;
            }
            
            // Handle string attributes like color="red"
            const stringMatches = cleanAttrs.matchAll(/(\w+)="([^"]+)"/g);
            for (const match of stringMatches) {
                const [, propName, value] = match;
                props += `${propName}: "${value}", `;
            }
            
            // Handle boolean attributes like disabled
            const booleanMatches = cleanAttrs.matchAll(/(\w+)(?!=)/g);
            for (const match of booleanMatches) {
                const propName = match[1];
                if (!cleanAttrs.includes(`${propName}=`)) {
                    props += `${propName}: true, `;
                }
            }
            
            // Remove trailing comma and close
            props = props.replace(/, $/, '') + '}';
            
            return props === '{}' ? 'null' : props;
        }
        
        function parseSimpleJSXProps(attrString) {
            if (!attrString || !attrString.trim()) return 'null';
            
            // Very basic JSX attribute parser
            // Convert style={{...}} to {style: {...}}
            // Convert other={value} to {other: value}
            let props = '{';
            const cleanAttrs = attrString.trim();
            
            // Handle style={{...}} pattern
            const styleMatch = cleanAttrs.match(/style=\{\{([^}]+)\}\}/);
            if (styleMatch) {
                props += `style: {${styleMatch[1]}}, `;
            }
            
            // Handle simple prop={value} patterns
            const propMatches = cleanAttrs.matchAll(/(\w+)=\{([^}]+)\}/g);
            for (const match of propMatches) {
                if (match[1] !== 'style') { // skip style, already handled
                    props += `${match[1]}: ${match[2]}, `;
                }
            }
            
            // Handle string props like className="test"
            const stringMatches = cleanAttrs.matchAll(/(\w+)="([^"]+)"/g);
            for (const match of stringMatches) {
                props += `${match[1]}: "${match[2]}", `;
            }
            
            // Remove trailing comma and close
            props = props.replace(/, $/, '') + '}';
            
            return props === '{}' ? 'null' : props;
        }

        function showFallbackScene(error) {
            console.log('üîÑ Showing fallback scene due to error:', error?.message || 'Unknown error');
            
            try {
                // Clear the root element
                const root = document.getElementById('root');
                root.innerHTML = '';
                
                // Create a simple, reliable fallback scene
                const fallbackScript = document.createElement('script');
                fallbackScript.textContent = `
                    try {
                        const React = window.React;
                        const { createRoot } = window.ReactDOM;
                        const { Canvas } = window.ReactThreeFiber;
                        const { OrbitControls } = window.Drei;
                        
                        function FallbackScene() {
                            return React.createElement(Canvas, {
                                style: { width: '100%', height: '100%' },
                                camera: { position: [3, 3, 3], fov: 75 }
                            },
                                // Ambient light
                                React.createElement(window.ambientLight, { intensity: 0.6 }),
                                // Directional light
                                React.createElement(window.directionalLight, {
                                    position: [5, 5, 5],
                                    intensity: 0.8
                                }),
                                // Simple cube
                                React.createElement(window.mesh, { position: [0, 0, 0] },
                                    React.createElement(window.boxGeometry, { args: [1, 1, 1] }),
                                    React.createElement(window.meshStandardMaterial, { color: '#ff6b6b' })
                                ),
                                // Ground plane
                                React.createElement(window.mesh, {
                                    rotation: [-Math.PI / 2, 0, 0],
                                    position: [0, -1, 0]
                                },
                                    React.createElement(window.planeGeometry, { args: [10, 10] }),
                                    React.createElement(window.meshStandardMaterial, { color: '#f0f0f0' })
                                ),
                                // Controls
                                React.createElement(OrbitControls)
                            );
                        }
                        
                        const rootElement = document.getElementById('root');
                        if (rootElement && window.ReactDOM && window.ReactDOM.createRoot) {
                            const reactRoot = window.ReactDOM.createRoot(rootElement);
                            reactRoot.render(React.createElement(FallbackScene));
                            console.log('‚úÖ Fallback scene rendered successfully');
                        }
                    } catch (fallbackError) {
                        console.error('‚ùå Fallback scene failed:', fallbackError);
                        // Last resort: show a simple message
                        const root = document.getElementById('root');
                        root.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-family: Arial, sans-serif;">Scene error - check console</div>';
                    }
                `;
                
                document.head.appendChild(fallbackScript);
                
                // Clean up after execution
                setTimeout(() => {
                    if (fallbackScript.parentNode) {
                        document.head.removeChild(fallbackScript);
                    }
                }, 500);
                
            } catch (error) {
                console.error('‚ùå Critical error in showFallbackScene:', error);
            }
        }
        
        function runBuiltScene() {
            if (!currentBundle) {
                console.error('No bundle to run');
                return;
            }
            
            try {
                // Clear the root element
                const root = document.getElementById('root');
                root.innerHTML = '';
                
                // Create a new script element and execute the bundle
                const script = document.createElement('script');
                script.textContent = currentBundle;
                document.head.appendChild(script);
                
                console.log('‚úÖ Scene executed successfully');
                
                // Clean up script element
                setTimeout(() => {
                    document.head.removeChild(script);
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Runtime error:', error);
                showConsole();
            }
        }
        
        async function callSwiftBuildService(code) {
            // This will be implemented by Swift side
            return new Promise((resolve) => {
                // Mock response for now
                setTimeout(() => {
                    resolve({
                        success: false,
                        bundleCode: null,
                        errors: ['Build service not yet connected'],
                        statusText: 'Build service unavailable'
                    });
                }, 1000);
            });
        }
        
        function getDefaultCode() {
            return `// Welcome to React Three Fiber!
// Create declarative 3D scenes with React components
// Using React.createElement syntax for browser compatibility

import React, { useRef } from 'react'
import { createRoot } from 'react-dom/client'
import { Canvas, useFrame } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'
import * as THREE from 'three'

function RotatingCube() {
  const meshRef = useRef(null);
  
  useFrame((state, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.x += delta * 0.5;
      meshRef.current.rotation.y += delta * 0.2;
    }
  });
  
  return React.createElement('mesh', 
    { ref: meshRef, position: [0, 1, 0] },
    React.createElement('boxGeometry', { args: [1, 1, 1] }),
    React.createElement('meshStandardMaterial', { color: 'hotpink' })
  );
}

function Scene() {
  return React.createElement(React.Fragment, null,
    React.createElement('ambientLight', { intensity: 0.6 }),
    React.createElement('directionalLight', { position: [2, 2, 2], intensity: 1 }),
    React.createElement(RotatingCube),
    React.createElement('mesh', 
      { rotation: [-Math.PI / 2, 0, 0], position: [0, -0.5, 0] },
      React.createElement('planeGeometry', { args: [10, 10] }),
      React.createElement('meshStandardMaterial', { color: '#888888' })
    ),
    React.createElement(OrbitControls)
  );
}

function App() {
  return React.createElement(Canvas, 
    { 
      style: { width: '100%', height: '100%' },
      camera: { position: [3, 3, 3], fov: 75 },
      gl: { antialias: true }
    },
    React.createElement(Scene)
  );
}

const root = createRoot(document.getElementById('root'));
root.render(React.createElement(App));`;
        }
        
        function loadDefaultScene() {
            console.log('üé¨ ANDROID DEBUG: Loading default scene immediately...');
            
            // First show a simple loading screen immediately
            showSimpleLoadingScreen();
            
            // Then try to load the 3D scene
            setTimeout(() => {
                tryLoad3DScene();
            }, 100);

            // üîß CRITICAL TEST: DISABLED - was interfering with user code execution
            // setTimeout(() => {
            //     testBasicSceneRendering();
            // }, 2000);
        }
        
        function testBasicSceneRendering() {
            console.log('üß™ ANDROID DEBUG: Testing basic scene rendering with verified components...');
            
            if (!window.React || !window.ReactDOM || !window.ReactThreeFiber) {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: Core libraries not ready for test - retrying in 1 second...');
                setTimeout(testBasicSceneRendering, 1000);
                return;
            }
            
            try {
                // Create a simple test scene using React.createElement with proper component references
                const TestScene = () => {
                    return window.React.createElement(window.ReactThreeFiber.Canvas,
                        { style: { width: '100%', height: '100%' } },
                        // Add comprehensive lighting using proper component references
                        window.React.createElement(window.ambientLight, { intensity: 0.5 }),
                        window.React.createElement(window.directionalLight, {
                            position: [2, 2, 2],
                            intensity: 1,
                            castShadow: true
                        }),
                        window.React.createElement(window.pointLight, {
                            position: [-2, 2, -2],
                            intensity: 0.5,
                            color: '#ffffff'
                        }),
                        // Add a simple test object using proper component references
                        window.React.createElement(window.mesh,
                            { position: [0, 0, 0] },
                            window.React.createElement(window.boxGeometry, { args: [1, 1, 1] }),
                            window.React.createElement(window.meshStandardMaterial, {
                                color: '#ff6b6b',
                                roughness: 0.3,
                                metalness: 0.1
                            })
                        ),
                        // Add OrbitControls if available
                        window.Drei && window.Drei.OrbitControls
                            ? window.React.createElement(window.Drei.OrbitControls)
                            : null
                    );
                };
                
                const root = document.getElementById('root');
                if (root && window.ReactDOM.createRoot) {
                    const reactRoot = window.ReactDOM.createRoot(root);
                    reactRoot.render(window.React.createElement(TestScene));
                    console.log('‚úÖ ANDROID DEBUG: Test scene rendered successfully with proper lighting');
                } else {
                    console.error('‚ùå ANDROID DEBUG: Root element or ReactDOM.createRoot not available');
                }
                
            } catch (error) {
                console.error('‚ùå ANDROID DEBUG: Test scene rendering failed:', error);
                console.error('   Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
            }
        }
        
        function showSimpleLoadingScreen() {
            console.log('üì∫ ANDROID DEBUG: Showing simple loading screen...');
            const root = document.getElementById('root');
            if (!root) {
                console.error('‚ùå ANDROID DEBUG: Root element not found!');
                return;
            }
            
            root.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    font-family: Arial, sans-serif;
                    text-align: center;
                    flex-direction: column;
                ">
                    <h2>React Three Fiber Playground</h2>
                    <p>Loading 3D Scene...</p>
                    <div style="
                        width: 50px;
                        height: 50px;
                        border: 3px solid rgba(255,255,255,0.3);
                        border-top: 3px solid white;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                        margin-top: 20px;
                    "></div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                </div>
            `;
            console.log('‚úÖ ANDROID DEBUG: Loading screen displayed');
        }
        
        function tryLoad3DScene() {
            console.log('üéØ ANDROID DEBUG: Attempting 3D scene load...');
            
            try {
                const root = document.getElementById('root');
                if (!root) {
                    console.error('‚ùå ANDROID DEBUG: Root element not found for 3D scene');
                    return;
                }
                
                // Create immediate default scene without waiting for Monaco
                const sceneScript = document.createElement('script');
                sceneScript.textContent = `
                    try {
                        console.log('üîß ANDROID DEBUG: Inside scene script...');
                        
                        // Wait for React libraries to be available
                        function tryRenderDefaultScene(attempts = 0) {
                            console.log('üîÑ ANDROID DEBUG: Render attempt', attempts, 'Library check:', {
                                React: !!window.React,
                                ReactDOM: !!window.ReactDOM,
                                ReactThreeFiber: !!window.ReactThreeFiber,
                                Drei: !!window.Drei,
                                THREE: !!window.THREE
                            });
                            
                            if (window.React && window.ReactDOM && window.ReactThreeFiber) {
                                const React = window.React;
                                const { createRoot } = window.ReactDOM;
                                const { Canvas, useFrame } = window.ReactThreeFiber;
                                const { OrbitControls } = window.Drei;
                                const THREE = window.THREE;
                                
                                function RotatingCube() {
                                    const meshRef = React.useRef();

                                    useFrame((state, delta) => {
                                        if (meshRef.current) {
                                            meshRef.current.rotation.x += delta * 0.5;
                                            meshRef.current.rotation.y += delta * 0.2;
                                        }
                                    });

                                    return React.createElement(window.mesh, {
                                        ref: meshRef,
                                        position: [0, 1, 0]
                                    },
                                        React.createElement(window.boxGeometry, { args: [1, 1, 1] }),
                                        React.createElement(window.meshStandardMaterial, { color: 'hotpink' })
                                    );
                                }

                                function DefaultScene() {
                                    return React.createElement(Canvas, {
                                        style: { width: '100%', height: '100%' },
                                        camera: { position: [3, 3, 3], fov: 75 },
                                        gl: { antialias: true }
                                    },
                                        React.createElement(window.ambientLight, { intensity: 0.6 }),
                                        React.createElement(window.directionalLight, {
                                            position: [2, 2, 2],
                                            intensity: 1
                                        }),
                                        React.createElement(RotatingCube),
                                        React.createElement(window.mesh, {
                                            rotation: [-Math.PI / 2, 0, 0],
                                            position: [0, -0.5, 0]
                                        },
                                            React.createElement(window.planeGeometry, { args: [10, 10] }),
                                            React.createElement(window.meshStandardMaterial, { color: '#888888' })
                                        ),
                                        React.createElement(OrbitControls)
                                    );
                                }
                                
                                const rootElement = document.getElementById('root');
                                const reactRoot = createRoot(rootElement);
                                reactRoot.render(React.createElement(DefaultScene));
                                console.log('‚úÖ Default scene loaded successfully');
                                
                            } else if (attempts < 20) {
                                // Retry until React libraries are loaded
                                setTimeout(() => tryRenderDefaultScene(attempts + 1), 200);
                            } else {
                                console.warn('‚ö†Ô∏è React libraries not available after 4 seconds, showing simple fallback');
                                showSimpleFallback();
                            }
                        }
                        
                        function showSimpleFallback() {
                            const root = document.getElementById('root');
                            root.innerHTML = \`
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    height: 100%;
                                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                    color: white;
                                    font-family: Arial, sans-serif;
                                    text-align: center;
                                    flex-direction: column;
                                ">
                                    <h2>React Three Fiber Playground</h2>
                                    <p>Loading 3D libraries...</p>
                                    <div style="
                                        width: 50px;
                                        height: 50px;
                                        border: 3px solid rgba(255,255,255,0.3);
                                        border-top: 3px solid white;
                                        border-radius: 50%;
                                        animation: spin 1s linear infinite;
                                        margin-top: 20px;
                                    "></div>
                                    <style>
                                        @keyframes spin {
                                            0% { transform: rotate(0deg); }
                                            100% { transform: rotate(360deg); }
                                        }
                                    </style>
                                </div>
                            \`;
                            console.log('Simple fallback scene shown');
                        }
                        }
                        
                        tryRenderDefaultScene();
                        
                    } catch (error) {
                        console.error('‚ùå Error loading default scene:', error);
                    }
                `;
                
                document.head.appendChild(sceneScript);
                
                // Clean up script after execution
                setTimeout(() => {
                    if (sceneScript.parentNode) {
                        document.head.removeChild(sceneScript);
                    }
                }, 2000);
                
            } catch (error) {
                console.error('‚ùå Critical error in loadDefaultScene:', error);
            }
        }
        
        function hideLoadingOverlay() {
            // Hide immediately, no timeout needed
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.style.display = 'none';
                console.log('‚úÖ ANDROID DEBUG: Loading overlay hidden');
            }

            // Send basic page ready notification immediately
            if (!editor) {
                console.log('üìÑ Page loaded, Monaco still loading...');
                notifySwiftInitialization({
                    editorReady: false,
                    engineReady: true,
                    framework: 'reactThreeFiber',
                    pageLoaded: true
                });
            }
        }
        
        // Expose functions for Swift integration
        window.insertCodeAtCursor = function(code) {
            if (editor) {
                const position = editor.getPosition();
                editor.executeEdits('', [{
                    range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                    text: code
                }]);
                editor.focus();
            }
        };
        
        window.getEditorContent = function() {
            return editor ? editor.getValue() : '';
        };
        
        window.setEditorContent = function(code) {
            if (editor) {
                editor.setValue(code);
            }
        };
        
        // Add enhanced functions that Swift expects
        window.setFullEditorContent = function(code) {
            console.log('üìù ANDROID DEBUG: setFullEditorContent called with code length:', code.length);
            
            // Check library status with more detailed information
            const libraryStatus = {
                React: !!window.React,
                ReactDOM: !!window.ReactDOM,
                ReactThreeFiber: !!window.ReactThreeFiber,
                Drei: !!window.Drei,
                THREE: !!window.THREE,
                editor: !!editor,
                loadingProgress: window.libraryLoadingProgress
            };
            
            console.log('üìö ANDROID DEBUG: Libraries available:', libraryStatus);
            
            // Send immediate status to Swift for debugging
            try {
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                    window.webkit.messageHandlers.playgroundHandler.postMessage({
                        action: 'libraryStatusUpdate',
                        data: {
                            libraries: {
                                React: libraryStatus.React,
                                ReactDOM: libraryStatus.ReactDOM,
                                ReactThreeFiber: libraryStatus.ReactThreeFiber,
                                Drei: libraryStatus.Drei,
                                THREE: libraryStatus.THREE
                            },
                            context: 'setFullEditorContent',
                            timestamp: Date.now()
                        }
                    });
                    console.log('üì° ANDROID DEBUG: Sent library status from setFullEditorContent');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: Could not send library status:', error);
            }
            
            if (editor) {
                try {
                    editor.setValue(code);
                    console.log('‚úÖ ANDROID DEBUG: Code set in editor successfully');
                    
                    // Auto-execute the injected code to ensure the scene updates
                    console.log('üé¨ ANDROID DEBUG: Auto-running injected code in 500ms...');
                    setTimeout(() => {
                        console.log('üéØ ANDROID DEBUG: Calling runScene() now...');
                        runScene();
                    }, 500);
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå ANDROID DEBUG: Error setting code:', error);
                    return false;
                }
            } else {
                console.warn('‚ö†Ô∏è ANDROID DEBUG: Editor not available for injection');
                return false;
            }
        };
        
        window.formatCode = function() {
            if (editor) {
                editor.getAction('editor.action.formatDocument').run();
            }
        };
        
        // üîß CRITICAL FIX: Direct code execution function for Swift
        window.executeCodeDirectly = function(code) {
            console.log('üéØ ANDROID DEBUG: executeCodeDirectly (Swift wrapper) called with code length:', code.length);
            console.log('üìä ANDROID DEBUG: Global state before call:', {
                isExecuting: window.isExecutingCode,
                lastExecutionTime: window.lastExecutionTime,
                callCount: window.executionCallCount || 0
            });
            executeCodeDirectlyInternal(code);
        };
        
        // üîß CRITICAL FIX: Force run test scene function for Swift
        window.runTestScene = function() {
            console.log('üß™ ANDROID DEBUG: runTestScene called from Swift');
            testBasicSceneRendering();
        };
        
        // üîß CRITICAL FIX: Force run default scene
        window.runDefaultScene = function() {
            console.log('üé¨ ANDROID DEBUG: runDefaultScene called from Swift');
            const defaultCode = getDefaultCode();
            executeCodeDirectly(defaultCode);
        };
        
        // üîß CRITICAL FIX: Reset execution lock manually
        window.resetExecutionLock = function() {
            console.log('üîì ANDROID DEBUG: Manually resetting execution lock');
            window.isExecutingCode = false;
            window.lastExecutionTime = 0;
            console.log('‚úÖ ANDROID DEBUG: Lock reset complete');
        };
        
        // üîß CRITICAL FIX: Check execution status
        window.checkExecutionStatus = function() {
            console.log('üìä ANDROID DEBUG: Execution status:', {
                isExecutingCode: window.isExecutingCode,
                lastExecutionTime: window.lastExecutionTime,
                timeSinceLastExecution: Date.now() - (window.lastExecutionTime || 0)
            });
        };
        
        // üîß CRITICAL FIX: Simple test without any transformation
        window.runSimpleTest = function() {
            console.log('üß™ ANDROID DEBUG: runSimpleTest called - testing basic React Three Fiber');
            
            try {
                // Clear the root
                const root = document.getElementById('root');
                root.innerHTML = '';
                
                // Create the simplest possible React Three Fiber scene
                const SimpleTestApp = () => {
                    return window.React.createElement(
                        window.ReactThreeFiber.Canvas,
                        { style: { width: '100%', height: '100%', background: '#1a1a2e' } },
                        // Lighting
                        window.React.createElement('ambientLight', { intensity: 0.6 }),
                        window.React.createElement('directionalLight', { 
                            position: [3, 3, 3], 
                            intensity: 1 
                        }),
                        // Simple red cube
                        window.React.createElement(
                            'mesh',
                            { position: [0, 0, 0] },
                            window.React.createElement('boxGeometry', { args: [2, 2, 2] }),
                            window.React.createElement('meshStandardMaterial', { 
                                color: '#ff4444',
                                roughness: 0.3,
                                metalness: 0.1
                            })
                        )
                    );
                };
                
                // Render it
                if (window.ReactDOM && window.ReactDOM.createRoot) {
                    const reactRoot = window.ReactDOM.createRoot(root);
                    reactRoot.render(window.React.createElement(SimpleTestApp));
                    console.log('‚úÖ ANDROID DEBUG: Simple test scene rendered successfully');
                } else {
                    console.error('‚ùå ANDROID DEBUG: ReactDOM.createRoot not available');
                }
                
            } catch (error) {
                console.error('‚ùå ANDROID DEBUG: Simple test failed:', error);
            }
        };
        
        // Notify Swift about initialization status
        function notifySwiftInitialization(data) {
            try {
                // iOS WebKit message handler
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playgroundHandler) {
                    const message = {
                        action: 'initializationComplete',
                        data: data
                    };
                    window.webkit.messageHandlers.playgroundHandler.postMessage(message);
                    console.log('‚úÖ Notified iOS about initialization:', data);
                }
                // Android JavaScript interface
                else if (window.AndroidBridge && window.AndroidBridge.postMessage) {
                    const message = {
                        action: 'initializationComplete',
                        data: data
                    };
                    window.AndroidBridge.postMessage(JSON.stringify(message));
                    console.log('‚úÖ Notified Android about initialization:', data);
                } else {
                    console.warn('‚ö†Ô∏è No native bridge available (iOS playgroundHandler or Android AndroidBridge)');
                }
            } catch (error) {
                console.warn('Could not notify native about initialization:', error);
            }
        }
        
        // Ensure readiness check variables are always available
        window.monaco = window.monaco || null;
        window.editor = window.editor || null;
        window.setFullEditorContent = window.setFullEditorContent || function() { return false; };
        
        // Manual library status checker for debugging
        window.checkLibraryStatus = function() {
            const status = {
                React: {
                    available: !!window.React,
                    type: typeof window.React,
                    hasCreateElement: !!(window.React && window.React.createElement),
                    hasUseState: !!(window.React && window.React.useState)
                },
                ReactDOM: {
                    available: !!window.ReactDOM,
                    type: typeof window.ReactDOM,
                    hasCreateRoot: !!(window.ReactDOM && window.ReactDOM.createRoot)
                },
                THREE: {
                    available: !!window.THREE,
                    type: typeof window.THREE,
                    hasScene: !!(window.THREE && window.THREE.Scene)
                },
                ReactThreeFiber: {
                    available: !!window.ReactThreeFiber,
                    type: typeof window.ReactThreeFiber,
                    hasCanvas: !!(window.ReactThreeFiber && window.ReactThreeFiber.Canvas),
                    hasUseFrame: !!(window.ReactThreeFiber && window.ReactThreeFiber.useFrame)
                },
                Drei: {
                    available: !!window.Drei,
                    type: typeof window.Drei,
                    hasOrbitControls: !!(window.Drei && window.Drei.OrbitControls)
                },
                loadingProgress: window.libraryLoadingProgress,
                librariesReady: librariesReady
            };
            
            console.log('üìä ANDROID DEBUG: Manual library status check:', status);
            return status;
        };
        
        // Export for debugging
        window.playgroundAPI = {
            editor,
            buildScene,
            runScene,
            clearConsole,
            showConsole,
            hideConsole,
            notifySwiftInitialization,
            checkLibraryStatus: window.checkLibraryStatus,
            validateLibraryLoaded,
            setupLibraryGlobals,
            loadAllLibraries
        };
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>m{ai}geXR</title>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/super-three@0.173.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/super-three@0.173.0/examples/jsm/"
        }
    }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #0A0A0A;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }

        #logo-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
            text-align: center;
        }

        .brand-text {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            font-size: 64px;
            font-weight: 700;
            letter-spacing: 2px;
            animation: neonPulse 2s ease-in-out infinite;
        }

        .m-text, .ge-text {
            color: #00FFF9;
            text-shadow: 0 0 20px #00FFF9, 0 0 40px #00FFF9;
        }

        .ai-text {
            color: #FF00C1;
            text-shadow: 0 0 20px #FF00C1, 0 0 40px #FF00C1;
        }

        @keyframes neonPulse {
            0%, 100% {
                opacity: 1;
                filter: brightness(1);
            }
            50% {
                opacity: 0.85;
                filter: brightness(1.2);
            }
        }

        /* Responsive logo sizing */
        @media (max-width: 430px) {
            .brand-text { font-size: 48px; }
        }

        @media (min-width: 768px) {
            .brand-text { font-size: 80px; }
        }

        /* Tap feedback */
        body.tapped {
            opacity: 0.95;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- m{ai}geXR Logo -->
    <div id="logo-overlay">
        <div class="brand-text">
            <span class="m-text">m</span><span class="ai-text">{ai}</span><span class="ge-text">geXR</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        console.log('m{ai}geXR Splash Screen - Three.js v' + THREE.REVISION);

        // Prevent scroll bounce
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'fixed';

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0A0A0A, 10, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize for mobile
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- VAPORWAVE SCENE COMPONENTS ---

        // 1. Sunset Sky Gradient (Background Plane)
        const skyGeometry = new THREE.PlaneGeometry(200, 100);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x9600FF) },    // neonPurple
                middleColor: { value: new THREE.Color(0xFF00C1) }, // neonPink
                bottomColor: { value: new THREE.Color(0x00FFF9) }  // neonCyan
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 middleColor;
                uniform vec3 bottomColor;
                varying vec2 vUv;

                void main() {
                    vec3 color;
                    if (vUv.y > 0.5) {
                        color = mix(middleColor, topColor, (vUv.y - 0.5) * 2.0);
                    } else {
                        color = mix(bottomColor, middleColor, vUv.y * 2.0);
                    }
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        sky.position.set(0, 0, -50);
        scene.add(sky);

        // 2. Sun Disc
        const sunGeometry = new THREE.SphereGeometry(8, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xFF00C1,
            emissive: 0xFF00C1,
            emissiveIntensity: 1
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(0, 0, -45);
        scene.add(sun);

        // 3. Grid Landscape (Animated)
        const gridHelper = new THREE.GridHelper(100, 50, 0x00FFF9, 0x00FFF9);
        gridHelper.material.opacity = 0.5;
        gridHelper.material.transparent = true;
        gridHelper.position.y = -2;
        gridHelper.rotation.x = 0;
        scene.add(gridHelper);

        // Secondary purple grid for depth
        const gridHelper2 = new THREE.GridHelper(100, 50, 0x9600FF, 0x9600FF);
        gridHelper2.material.opacity = 0.3;
        gridHelper2.material.transparent = true;
        gridHelper2.position.y = -2.1;
        gridHelper2.position.z = -10;
        scene.add(gridHelper2);

        // 4. Particle System
        const particleCount = window.innerWidth < 768 ? 1000 : 2000; // Adaptive for mobile
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        const neonColors = [
            new THREE.Color(0x00FFF9), // cyan
            new THREE.Color(0xFF00C1), // pink
            new THREE.Color(0x9600FF)  // purple
        ];

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = Math.random() * 50 - 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

            const color = neonColors[Math.floor(Math.random() * neonColors.length)];
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // --- POST-PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        // Unreal Bloom (neon glow)
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.2,  // strength (reduced for mobile performance)
            0.4,  // radius
            0.85  // threshold
        );
        composer.addPass(bloomPass);

        // RGB Chromatic Aberration
        const rgbShiftPass = new ShaderPass(RGBShiftShader);
        rgbShiftPass.uniforms['amount'].value = 0.0015;
        composer.addPass(rgbShiftPass);

        // Output pass for proper color rendering
        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // --- ANIMATION LOOP ---
        let gridSpeed = 0.05;
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animate grid movement (infinite scroll)
            gridHelper.position.z += gridSpeed;
            gridHelper2.position.z += gridSpeed * 0.8;

            if (gridHelper.position.z > 10) {
                gridHelper.position.z = -10;
            }
            if (gridHelper2.position.z > 5) {
                gridHelper2.position.z = -15;
            }

            // Animate particles (subtle drift)
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] += Math.sin(time + i * 0.1) * 0.002;
                positions[i * 3 + 2] += 0.01;

                // Reset particles that go too far
                if (positions[i * 3 + 2] > 50) {
                    positions[i * 3 + 2] = -50;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Rotate particles slowly
            particles.rotation.y += 0.0005;

            // Pulse sun slightly
            sun.scale.setScalar(1 + Math.sin(time * 2) * 0.05);

            composer.render();
        }

        animate();

        // --- RESPONSIVE RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- DISMISS HANDLER ---
        let dismissed = false;

        // Auto-dismiss after 2.5 seconds
        setTimeout(() => {
            if (!dismissed) {
                handleDismiss();
            }
        }, 2500);

        // User can tap/click to skip immediately
        function handleDismiss() {
            if (dismissed) return;
            dismissed = true;

            console.log('Dismissing splash screen');

            // Send message to Android via JavaScript interface
            if (typeof Android !== 'undefined' && Android.dismissSplash) {
                Android.dismissSplash();
            }
            // Fallback for iOS WebKit (if needed for cross-platform)
            else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.splashHandler) {
                window.webkit.messageHandlers.splashHandler.postMessage({
                    action: 'dismiss'
                });
            } else {
                console.warn('No native bridge available for dismiss');
            }
        }

        // Touch/click feedback
        document.addEventListener('touchstart', () => {
            document.body.classList.add('tapped');
        });

        document.addEventListener('touchend', (e) => {
            e.preventDefault();
            document.body.classList.remove('tapped');
            handleDismiss();
        });

        document.addEventListener('click', (e) => {
            e.preventDefault();
            handleDismiss();
        });

        console.log('Vaporwave splash scene initialized');
    </script>
</body>
</html>
